# 알고리즘 기초

## 알고리즘 소개

### 알고리즘 기본개념

주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 컴퓨터가 수행가능한 유한개의 일련의 명령을 순서적으로 구성한 것

다음의 조건을 만족한다

- input & output: 0개 이상의 외부입력과 1개 이상의 출력이 있어야 함
- definiteness: 명령은 모호하지 않고 명확해야 한다
- finiteness: 한정된 수의 단계를 거친 뒤 반드시 종료해야 한다
- effectiveness: 모든 명령들은 실행 가능해야 한다

### 알고리즘 설계

일반적으로 적용할 수 있는 알고리즘 설계기법은 존재하지 않음

비교적 많은 부류의 문제에 사용할 수 있는 기법으로는 greedy, divide and conquer, dynamic programming 등이 있음

#### 분할정복 (divide and conquer)

순환적으로 문제를 푸는 방법

문제를 더 이상 나눌 수 없을 때까지 작은 문제로 나누고, 나누어진 작은 문제를 각각 해결한 후 결합하여 원래의 문제를 해결하는 방식

- 분할(divide): 주어진 문제를 여러개의 작은 문제로 분할
- 정복(conquer): 작은 문제를 순환하여 더 이상 분할되지 않을때까지 분할함
- 결합(combine): 작은 문제의 정복된 해를 결합하여 원래 문제의 해를 구함

분할 정복을 적용한 알고리즘: 퀵정렬, 합병정렬, 이진탐색, 선택문제(n개의 원소중 i번째 작은원소 찾기...) ...

#### 동적 프로그래밍 (dynamic programming)

주어진 문제를 여러 개의 부분문제로 분할하고 가장 작은 부분부터 해를 구한뒤 이를 이용하여 입력크기가 큰 문제를 해결해 나가는 방법

동적 프로그래밍을 적용한 알고리즘: 플로이드 알고리즘(모든 쌍의 최단경로 찾기) ...

#### 욕심쟁이 (greedy)

어떤 기준에 따라 전후단계의 선택과 상관없이 각 과정마다 최적해를 선택해나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라 기대하는 방법
따라서 적용범위는 제한적이다.

욕심쟁이 방법을 적용한 알고리즘
: 프림 알고리즘(최소비용 신장트리), 크루스칼 알고리즘, 데이크스트라 알고리즘(단일 출발점에서 최단경로 구하기), 거스름돈 문제, 배낭문제

##### 거스름돈 문제

가게에서 고객에게 돌려준 거스름돈이 T 만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법은?
동전은 500원, 100원, 50원, 10원, 5원, 1원의 6종류가 있다고 가정

욕심쟁이 해법은 액면가가 큰 동전부터 뽑아서 거스름돈을 만드는 것

##### 배낭문제

최대 용량이 M인 배낭 하나와 무게 Wi, 이익Pi인 물체 n개가 있을 때, 배낭에 담을 물체의 이익을 최대화 하는 방법은?

욕심쟁이 해법은 단위 무게당 가장 이익이 많이 나는 물체를 순서대로 반복해서 넣으면 된다.

### 알고리즘 분석

알고리즘은 정확하고 효율적이어야 한다

#### 정확성 분석

알고리즘에 유효한 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성해야 한다

#### 효율성 분석

알고리즘을 수행하기 위해서 필요한 컴퓨터 자원 (메모리, 주변창치, 수행시간)의 측정을 통해 이루어짐

##### 공간 복잡도 (space complexity)

알고리즘을 실행시켜 완료까지 필요한 총 메모리의 양을 말함 (정적 공간 + 동적 공간)

##### 시간 복잡도

알고리즘을 실행시켜 완료하는 데 걸리는 시간

일반적으로 알고리즘의 총 수행시간은 단위 연산이 몇 번 수행되는가에 거의 비례한다

알고리즘의 수행시간은 주어진 입력 데이터의 상태에 영향을 받는다.
따라서 다양한 형태의 입력에 따라 수행되는 시간의 평균, 최선, 최악을 구하는 것이 필요하다.

### 점근성능

알고리즘 성능은 입력의 크기에 따라 달라지므로, 데이터의 양이 무한히 많아지는 상황을 전제로 알고리즘의 성능을 표현하는 것이 바람직하다

알고리즘의 성능은 단위 연산의 실행 빈도수를 통해 유도된 다항식의 수행시간에 대해서, 최고차항만을 이용하여 표시된다.

최고차항을 이용한 성능 표기값은 어림값이므로 정확한 성능을 표현할수는 없을지라도
알고리즘 간의 성능비교가 용이하고 데이터 개수의 증가에 따른 알고리즘 수행시간 증가추이를 쉽게 파악할 수 있다.

점근 성능을 표기하는 대표적인 방법으로 다음 세 가지 방법이 있다

함수 f와 g를 각각 양의 정수를 갖는 함수라 하면

- Big-oh (O): 어떤 양의 상수 `c`와 `n0`가 존재하여 모든 `n >= n0`에 대하여 `f(n) <= cg(n)`이면 `f(n) = O(g(n))`이다
- Big-omega (Ω): 어떤 양의 상수 `c`와 `n0`가 존재하여 모든 `n >= n0`에 대하여 `f(n) >= cg(n)` 이면 `f(n) = Ω(g(n))`이다
- Big-theta (Φ): 어떤 양의 상수 `c1, c2`와 `n0`가 존재하여 모든 `n >= n0`에 대하여 `c1g(n) <= f(n) <= c2g(n)`이면 `f(n) = Φ(g(n))`이다

함수 `f(n)`은 일반적으로 알고리즘의 수행시간을 나타낸다

이때 `f(n)`이 `O(g(n))`이라면, `n`이 무한히 커지더라도 `f(n)`의 값은 결국 `g(n)`의 상수 배보다 적다는 것을 의미한다
다시말해 O 표기법의 성능은 최악의 경우에 대해서도 알고리즘의 수행시간이 `O(g(n))`이 되고 `g(n)`을 함수의 점근적 상한이라 표현한다.

`Ω(g(n))`은 `f(n)`의 점근적 하한을 의미하며, 알고리즘 최선의 경우를 의미한다.

`f(n)`이 `g(n)`을 점근적 상한과 하한을 동시에 갖는경우 `Φ` 표기법을 사용한다.

예를 들어 복잡도 함수가 `O(n^3)`이라는 것은 점근적 상한 수행 시간이 `n^3`을 넘지 않는 함수 `f(n)`의 집합이다.
따라서 `f(n)`이 반드시 3차 함수일 필요는 없고 3차 함수 아래에 놓이기만 하면 된다

#### 점근성능의 효율성

주어진 함수 `f(n)`의 최고차항으로 표시한 점근성능의 연산시간 순서는 다음과 같다

`O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < ... < O(2^n) < O(n!)`

### 순환 알고리즘의 성능 (recursive)

이진 탐색(binary search) 알고리즘의 경우 주어진 리스트 중앙값과 탐색값의 비교를 통해
크기가 반으로 줄어든 리스트를 대상으로 동일한 이진 탐색과정을 반복한다.

이와 같이 알고리즘의 수행과정에서 자신의 알고리즘을 다시 수행하는 형태를 순환/재귀(recursive) 알고리즘이라 부른다.

순환 알고리즘의 수행시간을 나타내기 위해 점화식이 사용된다.

`n`은 1보다 큰 경우 `T(n)`을 다음과 같은 점화식으로 표현할 수 있다.

`T(n) = T(n/2) + c2, T(1) = c1`

위 식을 전개하여 점화식의 폐쇄형을 구하면 다음과 같다

```text
T(n) = T(n/2) + c2 = T(n/4) + c2 + c2
= T(n/2^2) + 2c2 = T(n/8) + c2 + c2 + c2
= T(n/2^3) + 3c2 = T(n/2^(k-1)) + (k-1)c2
= T(1) + kc2 (n = 2^k 인경우 정의 가능 k = log2n)
= c1 + kc2
= c1 + c2log2n
```

이를 점근 표기법으로 나타내면 `O(logn)`이 된다

몇 가지 기본적인 알고리즘의 점화식에 대한 폐쇄형을 정리하면 다음과 같다

| 점화식 | 폐쇄형 | CASE |
| --- | --- | --- |
| `T(n) = T(n-1) + Φ(1), n >= 2` | `T(n) = Φ(n)` | |
| `T(n) = T(n-1) + Φ(n), n >= 2` | `T(n) = Φ(n^2)` | 퀵정렬(최악) |
| `T(n) = T(n/2) + Φ(1), n >= 2` | `T(n) = Φ(log2n)` | 이진탐색 |
| `T(n) = T(n/2) + Φ(n), n >= 2` | `T(n) = Φ(n)` | |
| `T(n) = 2T(n/2) + Φ(1), n >= 2` | `T(n) = Φ(n)` | |
| `T(n) = 2T(n/2) + Φ(n), n >= 2` | `T(n) = Φ(nlog2n)` | 퀵정렬(최선), 합병정렬 |

## 정렬

### 정렬의 개념

정렬은 여러 원소로 구성된 데이터를 크기 순서에 따라 재배열하는 것

비교 기반 정렬은 데이터의 키 값을 비교하면서 정렬하는 방식으로, 시간 복잡도는 키의 비교횟수에 비례한다.
> 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬, 합병 정렬, 퀵 정렬, 힙 정렬 ...

분포 기반 정렬은 데이터의 분포 정보를 이용하여 정렬하는 방식으로, 선형시간 복잡도를 가진다.
> 계수 정렬, 버킷 정렬, 기수 정렬 ...

안정적 정렬은 데이터의 키 값이 동일한 경우 정렬 후 기존 순서가 변하지 않는 정렬이다.
제자리 정렬은 입력받은 데이터가 저장된 공간 이외의 별도 공간을 상수개만 사용하는 정렬이다.

### 선택 정렬

선택정렬은 원소중 가장 작은 키값을 갖는 원소를 선택하여 차례대로 나열하는 정렬방식이다

`{ 30, 50, 7, 40, 88, 15, 44 }` 의 배열을 정렬해보면

1. 첫 번째 원소 30을 기준으로 오른쪽으로 최소값을 찾기 시작한다.
2. 50은 30보다 더 크므로 다시 오른쪽 값을 비교한다.
3. 7은 30보다 더 작으므로 7을 최소값 기준으로 설정한다
4. 40은 7보다 크므로 다시 오른쪽 값을 비교한다.
5. ... 마지막 원소인 44까지 진행한다
6. 44는 7보다 크므로 최소값은 7이된다.
7. 첫 번째 원소와 찾은 최소값인 7의 자리를 바꾼다.
8. 두 번째 원소를 대상으로 1 ~ 7 과정을 반복한다.

#### 선택 정렬 알고리즘

```python
def SelectionSort(dlist):
    size = len(dlist)
    for element in range(size): # range는 반폐구간
        min_position = element
        for target in range(element + 1, size):
            if (dlist[target] < dlist[min_position]):
                min_position = target
        (dlist[element], dlist[min_position]) = (dlist[min_position], dlist[element])
```

#### 선택 정렬 알고리즘 성능

선택 정렬 알고리즘은 이중 반복문으로 구성되며 둘 다 입력 배열 크기 `n`에 비례하므로 전체 수행시간은 `O(n^2)` 이다.
입력 배열 크기 이외의 인자가 없으므로 최악, 최선, 평균 수형시간 모두 `O(n^2)` 이다.

#### 선택 정렬 특징

1. 언제나 동일 수행시간 `O(n^2)`을 보임
2. 안정적이지 않은 정렬임
3. 제자리 정렬임: 데이터가 움직이는 경우는 두 원소 교환밖에 없음 (저장공간 이외의 공간을 상수개만 사용)

### 버블 정렬

버블 정렬은 인접한 두 원소를 차례대로 비교하면서 자리바꿈을 통해 정렬하는 방식이다.

`{ 30, 50, 7, 40, 88, 15, 44 }` 의 배열을 정렬해보면

1. 첫 번째 30과 두 번째 50을 비교한다.
2. 30이 50보다 작다. 두 번째 50과 세 번째 7을 비교한다.
3. 50이 7보다 크다. 두 수의 자리를 바꾼다.
4. 세 번째 50을 다시 네 번째 40과 비교한다.
5. 50이 40보다 크다. 두 수의 자리를 바꾼다.
6. ... 반복하여 n-1번째 원소와 n번째 원소를 비교할때 까지 진행한다.
7. 다시 1 ~ 6의 과정을, 정렬된 원소 이전까지 반복한다.

#### 버블 정렬 알고리즘

```python
def BubbleSort(dlist):
    size = len(dlist) - 1
    for element in range(size):
        for head in range(size - element):
            if (dlist[head] > dlist[head + 1]):
                (dlist[head], dlist[head + 1]) = (dlist[head + 1], dlist[head])
```

#### 버블 정렬 알고리즘 성능

버블 정렬 알고리즘은 이중 반복문으로 구성되며
바깥 반복은 조건에 따라 최소 상수, 최대 `n`에 비례하고, 안쪽 반복은 `n`에 비례한다.

수행시간은 최선의 경우 `O(n)`, 최악의 경우 `O(n^2)`, 평균의 경우 `O(n^2)`이다.

#### 버블 정렬 특징

1. 선택 정렬에 비해 원소의 교환이 많이 발생함: 수행시간이 최악인 경우 (`O(n^2)`) 선택 정렬보다 비효율적임
2. 안정적인 정렬임
3. 제자리 정렬임

## 탐색 (Search)

탐색이란 여러 원소로 구성된 데이터에서 원하는 원소를 찾는 것이다.

탐색은 저장 형태에 따라 구분된다. 저장형태는 list, tree, graph, table, string 등이 있다.

### 순차 탐색

### 이진 탐색

이진 탐색은 정렬된 리스트 형태로 주어진 원소들을 절반씩 나누어 가운데 원소를 기준으로 원하는 키값을 갖는 원소를 찾는 탐색방식이다.

`{ 7, 15, 22, 30, 35, 40, 44, 55, 88 }`의 배열에서 44를 찾는다고 하면

1. 먼저 가운데 원소인 35와 44를 비교한다.
2. 35가 44보다 작으므로 35의 오른쪽 부분에 대해 탐색을 진행한다.
3. `{ 40, 44, 55, 88 }`의 배열을 대상으로 가운데 원소인 55와 44를 비교한다.
4. 55가 44보다 크므로 55의 왼쪽 부분에 대해 탐색을 진행한다.
5. `{ 40, 44 }`의 배열을 대상으로 가운데 원소인 44를 찾을 수 있다.

#### 이진 탐색 알고리즘

```python
def binary_search(dlist, target):
    left = 0
    right = len(dlist) - 1
    while (left <= right):
        mid = (left + right) // 2
        if (dlist[mid] == target):
            return mid
        elif (dlist[mid] < target):
            left = mid + 1
        else:
            right = mid - 1
    return None
```

순환(재귀) 알고리즘으로 구현할 수 있다.

```python
def binary_search_recursion(dlist, target, left, right):
    if (left > right): return None
    mid = (left + right) // 2

    if (dlist[mid] == target):
        return mid
    elif (dlist[mid] < target):
        left = mid + 1
    else:
        right = mid - 1

    return binary_search_recursion(dlist, target, left, right)
```

#### 이진 탐색 성능 분석

이진 탐색 알고리즘은 하나의 반복문으로 구성된다.
반복마다 원소의 개수가 절반으로 감소한다. 따라서 최악, 평균 수행시간 모두 `O(logn)`이다.

#### 이진 탐색 특징

이진 탐색은 정렬된 리스트가 입력값으로 들어와야 적용 가능하다
