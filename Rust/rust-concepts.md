# Rust Concepts

## 변수와 가변성

러스트의 변수는 불변성(immutability)을 기본으로 하며 필요시 변수를 변경하도록 선언한다.

변수의 이름 앞에 `mut` 키워드를 추가하면 가변 변수를 선언할 수 있다.

### 변수와 상수의 차이점

불변 변수의 개념은 상수(constant)와 비슷하다. 하지만 상수와 변수 사이에는 몇 가지 차이점이 있다.

- 상수는 `mut` 키워드를 사용할 수 없다
- 상수는 `const` 키워드로 선언하며 할당할 값의 타입을 반드시 지정해야 한다
- 상수는 전역범위를 포함한 어느 범위에도 선언할 수 있다
- 상수는 반드시 상수 표현식으로 값을 할당해야 하며, 함수 호출 결과나 런타임 연산 결과를 사용할 수 없다

### 변수 shadowing

이미 선언한 변수의 이름과 똑같은 이름의 변수를 선언할 수 있다.
이때, 이전에 선언한 변수는 새로 선언한 변수에 가려진다.

변수를 새로 선언하는 것이므로 이전에 선언한 변수와 무런 상관이 없다.(다른 타입을 지정할 수 있다)

## 데이터 타입

러스트는 정적 타입언어이므로 컴파일 시점에 모든 변수의 타입이 결정되어야 한다.

여러 타입이 사용될 수 있는 경우 타입 애노테이션을 이용하여 타입을 명시하여야 한다.

`let guess: u32 = "42".parse().expect("숫자가 아닙니다");`

### 스칼라 타입 (Scalar Type)

스칼라 타입은 하나의 값을 표현한다.

- 정수(integer)
- 부동 소수점(floating point number)
- 불리언(Boolean)
- 문자(characters)

#### 정수 타입

- 8bit: i8 / u8
- 16bit: i16 / u16
- 32bit: i32 / u32
- 64bit: i64 / u64
- arch: isize / usize

arch 타입은 실행환경에 따라 다른데, 64bit 아키텍처에서는 64bit, 32bit 아키텍처에서는 32bit로 작동한다.

정수 리터럴은 타입 접미사를 붙여서 사용할 수 있으며, (`1_000` 밑줄을 이용해서 자릿수를 표시할 수 있다)

- Decimal: 98_222
- Hex: 0xff
- Octal: 0o77
- Binary: ob1111_0000
- Byte(u8전용): b'A'

정수의 기본타입은 i32이다.

#### 부동 소수점 타입

러스트는 두 개의 부동소수점 타입(f32, f64)을 지원하며 f64를 기본타입으로 한다.

부동 소수점은 IEEE754 표준을 따르고 있다.

#### 불리언 타입

러스트의 불리언 타입 크기는 1byte이며 `true` 혹은 `false`의 값을 가진다.

#### 문자 타입

러스트의 `char` 타입은 4byte 크기의 유니코드 스칼라 값이다.

스칼라 값의 범위는 U+0000~U+D7FF, U+E000~U+10FFFF 이다.

### 컴파운드 타입(Compound Type)

컴파운드 타입은 하나의 타입으로 여러 개의 값을 그룹화한 타입니다.

러스트는 기본적으로 튜플(tuples)과 배열(arrays)의 두 가지 컴파운드 타입을 지원한다.

#### 튜플 타입

튜플은 서로 다른 타입의 여러 값을 고정된 길이를 가진 하나의 타입으로 그룹화한다.

튜플을 생성할 때는 괄호 안에 값의 목록을 쉼표로 구분한다.

튜플에서 개별 값을 읽으려면 패턴 매칭을 이용해 튜플 값을 해체하거나 인덱스로 접근한다.

```rust
fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);

  let (x, y, z) = tup;
  let x = tup.0;
}
```

#### 배열 타입

배열은 같은 타입의 여러 요소를 고정된 길이를 가진 하나의 타입으로 그룹화한다.

배열에 저장할 값은 대괄호안의 목록을 쉽표로 구분한다.

배열의 요소에 접근하기 위해서는 인덱스를 사용한다

```rust
fn main() {
  // 배열선언
  let x: [i32; 5] = [1, 2, 3, 4, 5];

  // 동일한 값을 가진 배열 선언
  let y = [3; 5];

  // 배열에 접근
  let a = x[0];
}
```

배열은 다루고자 하는 데이터를 heap이 아닌 stack 메모리에 할당하거나, 항상 고정된 개수의 요소를 다룰 때 유용하다.

표준 라이브러리에서는 배열을 유연하게 사용할 수 있는 Vector 자료구조를 지원한다.

유효하지 않은 배열요소에 접근하면 `index out of bound` 패닉이 발생한다.

### 함수

러스트에서는 프로그램 진입점인 `main` 함수를 사용했으며, 함수를 선언하는 `fn` 키워드를 사용하기도 했다.

- 러스트는 함수와 변수의 이름에 snake_case를 사용한다

- 함수 시그니처에는 각 매개변수 타입을 명시해야 한다

- 여러 개의 매개변수를 선언할 때는 매개변수를 쉼표로 구분한다

- 함수의 본문은 여러개의 구문(statement)과 표현식(expression)으로 표현된다

  - 구문은 어떤 동작을 실행하지만 값을 반환하지는 않는다
  - 표현식은 최종 결과 값으로 평가된다

- 함수의 리턴 타입은 함수이름() 옆 화살표 (->) 다음에 지정한다

### 흐름제어

### 조건문

if 표현식은 조건에 따라서 코드를 분기한다

```rs
fn main() {
  let number = 6;

  if number % 4 == 0 {
    println!("변수는 4의 배수");
  } else if number % 3 == 0 {
    println!("변수는 3의 배수");
  } else {
    println!("기타...");
  }
}
```

if는 표현식이다

```rs
fn main() {
  let condition = true;
  let number = if condition {
    5
  } else {
    6
  };

  println!("number: {}", number);
}
```

### 반복문

러스트는 loop, while, for 세 가지 루프를 제공한다

#### loop

loop는 중지를 명령하지 않는 한 코드 블록을 무한으로 반복한다

루프를 중지하면서 값을 반환하려면 `break` 키워드 다음 반환 값을 명시하면 된다

```rs
fn main() {
  let mut counter = 0;

  let result = loop {
    counter += 1;

    if counter == 0 {
      break counter * 2;
    }
  }
}
```

#### while

조건식의 평가 결과에 따라 실행되는 반복문은 `while`을 사용한다

```rs
fn main() {
  let mut number = 3;

  while number != 0 {
    number = number - 1;
  }

  println!("종료");
}
```

#### for

```rs
fn main() {
  let arr = [10, 20, 30, 40, 50];

  for ele in arr.iter() {
    println!("값: {}", ele);
  }
}
```
