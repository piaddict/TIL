# Rust Ownership

## 소유권이란

소유권은 러스트의 핵심기능이다.

어떤 언어는 GC를 이용해 더 이상 사용되지 않는 메모리를 지속적으로 찾아 자동 해제 한다.
또 다른 언어는 프로그래머가 명시적으로 메모리를 할당하고 해제해 주어야 한다.

러스트는 앞의 두 방법이 아닌, 컴파일러가 컴파일 시점에 검사하는 다양한 규칙으로 이루어진 소유권 시스템으로 메모리를 관리한다.

### Stack memory & Heap memory

스택에 저장하는 데이터는 고정된 크기를 가져야한다.
컴파일 시점에 크기를 알 수 없는 데이터나 런타임에 동적으로 크기가 변하는 데이터는 힙 메모리에 저장한다.

힙 메모리 할당은 운영체제가 힙 메모리에서 일정한 공간을 찾아 사용중인 메모리로 표시한 후 해당 메모리의 주소인 포인터를 넘겨주는 것이다.

메모리 사이를 여러번 이동해야 하므로 힙 메모리에 저장된 데이터에 대한 접근은 스택에 저장된 데이터 접근보다 느리다.

코드에서 함수를 호출할 때 이 함수에는 힙 메모리에 저장된 데이터에 대한 포인터를 포함한 여러 값이 전달되며,
이 값들은 함수의 로컬 변수에 할당되어 스택에 저장되고 함수의 실행이 완료되면 이 값들은 스택에서 제거된다.

러스트의 소유권 기능은 힙 메모리에 있는 데이터를 관리하기 위한 기능으로 이해할 수 있다.

### 소유권 규칙

- 러스트가 다루는 각각의 값은 owner 변수를 가지고 있다
- 특정 시점에 값의 소유자는 단 하나 뿐이다
- 소유자가 범위를 벗어나면 그 값은 제거된다

### 메모리와 할당

가변 크기를 가진 변수를 처리하기 위해서는 두 가지 절차를 거쳐야 한다

- 해당 메모리는 반드시 런타임에 운영체제에 요청한다
- 사용이 완료된 후 메모리를 운영체제에 돌려줄 방법이 필요하다

러스트는 메모리의 할당과 해제를 범위(scope)로 처리한다.

```rs
{
  let s = String::from("hello"); // 변수 s는 이 지점부터 유효
}
// 범위를 벗어나므로 변수 s는 유효하지 않음
```

러스트는 닫는 중괄호를 만나면 자동으로 `drop` 함수를 호출한다.

#### 이동(Move)

```rs
let x = 5;
let y = x;
```

정수는 고정 크기의 단순한 값이므로 5라는 값 두 개가 스택에 저장된다

```rs
let s1 = String::from("hello");
let s2 = s1;
```

String 타입은 문자열 콘텐츠를 저장하고 있는
메모리 포인터(memory pointer), 길이(length), 용량(capacity) 세 부분으로 구성되며 이 데이터들은 스택에 저장된다.

s1을 s2에 대입하면 문자열에 대한 포인터, 길이, 용량이 스택에 복사된다.

러스트는 변수가 범위를 벗어나면 자동으로 `drop` 함수를 호출하여 힙 메모리를 정리한다.
문제는, 두 데이터 포인터가 동일한 메모리를 가리키고 있다는 점이다.

이 문제는 double free error라고 하며, memory curruption 발생으로 보안 취약점이 될 수있다.

러스트는 할당된 메모리를 복사하는 대신 변수 s1이 더 이상 유효하지 않다고 판단한다.
앞의 코드에서 s2에 변수 s1을 대입한 다음 변수 s1을 다시 참조하면 작동하지 않는다.

러스트는 첫 번째 변수를 무효화하므로 얕은 복사가 아닌 이동(move)으로 처리한다.

#### 복제(Clone)

스택 데이터가 아니라 힙 메모리에 저장된 데이터를 복사하려면 `clone`이라는 공통 메소드를 사용하면 된다.

```rs
let s1 = String::from("hello");
let s2 = s1.clone();
```

#### 복사(Copy)

```rs
let x = 5;
let y = x;
```

정수형 같은 타입은 컴파일 시점에 크기를 알 수 있으며, 온전히 스택에 저장되므로 값을 복사해도 부담이 적다.
따라서 변수 x를 변수 y에 대입한 후 무효화 할 이유가 없다.

러스트는 스택에 저장되는 타입에 적용할 수 있는 Copy trait라는 특성을 제공한다.

어떤 타입에 Copy trait가 적용되어 있다면 이전 변수를 새 변수에 대입해도 무효화 하지 않는다.
다만, 어떤 타입에 Drop trait가 적용되어 있으면 Copy trait을 적용할 수 없다.

### 소유권과 함수

변수를 함수에 전달하면 대입과 마찬가지로 값의 이동이나 복사가 이루어진다.

```rs
fn main() {
  let s = String::from("hello");
  takes_ownership(s); // 변수 s 값이 함수내로 이동하고 s는 더이상 유효하지 않음

  let x = 5;
  makes_copy(x); // 변수 x값이 함수내로 복사됨
}

fn takes_ownership(some_string: string) { // some_string 변수가 범위내 생성
  println!("{}", some_string);
} // some_string 변수가 범위를 벗어나며 drop 호출

fn makes_copy(some_interger: i32) { // some_integer 변수가 범위내 생성
  println!("{}", some_integer);
} // some_integer 변수가 범위를 벗어남 (stack에서 제거)
```

### 반환값과 범위

반환 값도 소유권을 이전한다

```rs
fn main() {
  let s1 = gives_ownership();

  let s2 = String::from("hello");

  let s3 = takes_and_gives_back(s2); // 변수 s2가 takes_and_gives_back 함수로 옮겨가고 반환값은 s3로 옮겨간다
}
// 범위를 벗어나면 s1, s3는 drop 함수가 호출되지만, s2는 함수로 옮겨갔으므로 아무일도 일어나지 않는다

fn gives_ownership() -> string {
  let some_string = String::from("hello");
  some_string // 변수를 반환하고 호출한 함수로 옮겨진다
}

fn takes_and_gives_back(a_string: String) -> String {
  a_string // 변수를 반환하고 호출한 함수로 옮겨진다
}
```

## 참조와 대여

값의 소유권을 가져오는 대신, 매개변수로 전달된 객체의 참조를 이용하도록 할 수 있다

```rs
fn main() {
   let s1 = String::form("hello");
   let len = calculate_length(&s1);
}

fn calculate_length(s: &String) -> usize {
  s.len()
}
```

ampersands 기호가 참조(references)이며 이를 이용하면 소유권을 가져오지 않고도 값을 참조할 수 있다.
참조는 소유권을 갖지 않기 때문에 참조가 범위를 벗어나더라도 drop 함수가 호출되지 않는다.

이처럼 함수 매개변수로 참조를 전달하는 것을 대여(borrowing)라고 한다.

변수가 기본적으로 불변인 것처럼 참조도 기본적으로 불변이므로, 참조하고 있는 값을 변경할 수 없다.

### 가변 참조

```rs
fn main() {
  let mut s = String::from("hello");
  change(&mut s);
}

fn change(some_str: &mut String) {
  some_str.push_str(", world");
}
```

변수에 `mut` 키워드를 추가하고 `&mut s`와 같은 가변참조를 전달한다.
그러나, 특정 범위 내의 특정 데이터에 대한 가변 참조는 오직 하나만 존재해야 한다.

이러한 제약으로 러스트는 데이터 경합을 컴파일 시점에서 방지할 수 있다.

데이터 경합은 race condition과 유사하며 주로 다음의 동작으로 인해 발생한다

- 둘 혹은 그 이상의 포인터가 동시에 같은 데이터를 읽거나 쓰기 위해 접근할 때
- 최소한 하나의 포인터가 데이터를 쓰기 위해 사용될 때
- 데이터에 대한 접근을 동기화할 수 있는 메커니즘이 없을 때

중괄호를 사용하면 새로운 범위를 생성할 수 있으므로 동시에 활용할 수는 없지만 여러개의 가변참조를 사용할 수 있다.

만약 동일 범위내에서 불변참졸르 이미 사용하고 있다면 가변참조를 생성할 수 없다.

```rs
let mut s = String::from("hello");

let r1 = &s;
let r2 = &s;
let r3 = &mut s; // 오류 발생
```

### 죽은 참조

포인터를 사용하는 언어는 죽은 포인터로 인해 에러가 발생하기 쉽다.

죽은 포인터란 이미 해제되어 다른 정보를 저장하도록 변경된 메모리를 계속해서 참조하는 포인터를 말한다.

러스트는 죽은 참조가 발생하지 않도록 컴파일러가 보장한다.

```rs
fn main() {
  let reference_to_nth = dangle();
}

fn dangle() -> &String { // 오류발생
  let s = String::from("hello");
  &s
}
```

### 참조에 대한 규칙

- 어느 한 시점에 코드는 하나의 가변 참조 또는 여러 개의 불변참조를 생성할 수는 있다
- 참조는 항상 유효해야 한다

## 슬라이스 타입

### 문자열 슬라이스

string slice는 String 일부에 대한 참조이다

```rs
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

슬라이스는 시작 위치로부터 길이 만큼의 데이터를 저장하는 구조체이다

인덱스표기에서 0과 마지막은 생략 가능하다, 즉 다음 코드는 위 코드와 동일하다

```rs
let s = String::from("hello world");

let hello = &s[..5];
let world = &s[6..];
```

문자열 리터럴은 바이너리의 한 지점을 가리키는 슬라이스인 것이고 `&str`은 불변참조이므로 항상 불변이다.

따라서, 문자열을 파라미터로 받는 함수는 문자열 슬라이스를 매개변수로 사용할 수 있다. (전체 길이의 슬라이스가 문자열이다)

### 다른 타입의 슬라이스

문자열 대상이 아닌 보편적인 슬라이스 타입을 사용할 수 있다.

```rs
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```

이 슬라이스는 `&[i32]` 타입이다.
