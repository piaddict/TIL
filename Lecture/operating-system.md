# 운영체제

## 운영체제 개요

### 운영체제의 개요

#### 컴퓨터 시스템과 운영체제

1. 하드웨어와 응용 프로그램 사이에 운영체제를 두고 하드웨어 제어는 운영체제만 하도록 하였다
2. 여러 응용 프로그램이 동시에 수행되더라도 운영체제가 중간에서 충돌 없이 자원을 효율적으로 나누어준다
3. 응용 프로그램이 직접 하드웨어에 접근하는 것을 방지하기 위해서 슈퍼바이저 모드와 보호보드가 사용된다.
  > 슈퍼바이저모드(커널모드): 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드로 운영체제의 커널이 동작되는 모드
  > 보호모드(사용자모드): 하드웨어를 직접 제어하는 CPU의 명령어를 사용할 수 없는 모드로 응용 프로그램이 동작하는 모드

#### 커널

응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할을 하는 운영체제의 핵심 요소를 Kernel 이라고 한다.
커널은 운영체제마다 구성 방식이 다른데, 대표적으로 일체형 커널과 마이크로 커널이 있다.

일체형 커널 (monolithic kernel)

운영체제의 모든 서비스가 커널 내에 포함된 커널이다.
장점은 커널 내부 요소로 존재하는 서비스들이 서로 효율적으로 상호작용 할 수 있다는 것이다.
단점은 하나의 요소에서 오류가 발생하면 시스템 전체에 장애를 일으킬 수 있다는 것이다.
UNIX와 Linux 운영체제가 일체형 커널이다.

마이크로 커널 (micro kernel)

운영체제의 대부분 요소들을 커널 외부로 분리하여 커널 내부에는 메모리 관리,멀티태스킹, 프로세스 간 통신(IPC) 등의 최소한의 요소들만 남겨 놓은 커널이다.
파일시스템, 장치 드러이버, 네트워크 프로토콜 들은 보호 모드에서 동작하도록 분리된다.
장점은 새로운 서비스를 추가하여 운영체제를 확장하기 쉬우며 커널 외부의 요소에 문제가 발생해도 커널 자체에는 영향이 없어 안정성이 우수하다.
단점은 커널 외부에 존재하는 운영체제 요소들 사이에 데이터 전달이 필요한 경우에는 IPC를 통해야 하기 때문에 성능저하가 발생한다.

### 운영체제의 구성

#### 프로세스 관리자

프로세스(실행중인 프로그램 또는 작업) 관리자는 프로세스들을 생성하고 삭제하며 CPU에 할당하기 위한 스케줄을 결정한다.
또한 각 프로세스의 상태(준비, 실행, 대기 등)를 관리하며 상태 전이를 처리한다.

#### 메모리 관리자

메모리 관리자는 주기억장치를 관리한다. 요청에 따라 메모리를 할당하고 테이블을 만들어 관리한다. 회수 시점에 메모리를 회수한다.
또 다른 역할은 운영체제가 점유하고 있는 주기억 장치의 공간을 지키는 것이다.

#### 장치 관리자

장치 관리자는 시스템의 모든 장치를 관리한다. 시스템 스케줄링 기법을 기반으로 장치를 효율적으로 할당한다.

#### 파일 관리자

파일 관리자는 시스템의 모든 파일을 관리한다. 또한 파일의 접근 제한을 관리하거나 파일을 열어 자원을 할당하거나 파일을 닫아 자원을 회수한다.

### 운영체제 유형

#### 일괄처리 운영체제

일괄처리(batch processing) 운영체제는 초창기 컴퓨터에서 사용되었던 유형으로 작업을 모아서 처리하는 방식이다.

#### 대화형 운영체제

대화형(interactive) 운영체제는 시분할 운영체제라고도 하며,
응답시간 측면에서 일괄처리 운영체제보다는 빠르지만 실시간 운영체제보다는 느리다.
대화형 운영체제는 이용자에게 즉각적인 피드백을 제공하고 응답시간은 사용 중인 이용자의 수에 따라 수 분 또는 수 초 안에 처리된다.

#### 실시간 운영체제

실시간(real-time) 운영체제는 운영체제 중 가장 빠른 응답시간을 가진다.
데이터의 처리가 빨라야 하는 환경인, 우주 비행 시스템, 미사일 제어, 증권 거래 등의 분야에 사용된다.

#### 하이브리드 운영체제

하이브리드(hybrid) 운영체제는 일괄처리와 대화형 운영체제의 결합으로 볼 수 있다.
각 이용자가 터미널을 통해 접속하고 빠른 응답시간을 얻을 수 있기 때문에 대화형이지만,
작업량이 많지 않을 경우 운영체제는 백그라운드에서 배치 프로그램을 받아들이고 실행한다.
현재 사용되고 있는 대부분의 대형 컴퓨터 시스템은 하이브리드 운영체제라고 할 수 있다.

## 프로세스 개요

### 프로세스

프로세스란 실행 중인 프로그램을 의미함
프로그램을 실행시키려면 운영체제로부터 동작하는데 필요한 CPU, 메모리, 입출력장치, 파일 등의 자원을 할당받아야 한다.

프로세스는 사용자가 실행시킨 프로그램 뿐만 아니라 스풀링과 같은 시스템 태스크도 각각 하나의 프로세스 이다.

운영체제는 프로세스의 상태를 관리하며 필요한 경우 프로세스가 다른 상태로 전이되도록 처리한다.

#### 프로세스의 상태 변화

프로세스는 `생성 -> [ 준비, 실행, 대기 ] -> 종료`의 다섯가지 중 하나의 상태를 가진다.

1. 생성 -> 준비 : 정의된 정책에 따라 스케줄러에 의해 호출된다. 이용가능한 메모리와 요구 장치를 검사한다.
2. 준비 -> 실행 : 사전에 정의된 알고리즘 (FCFS, SJF, SRT, RR ...)에 따라 스케줄러에 의해 처리된다 (dispatch)
3. 실행 -> 준비 : 할당 시간의 만료나 우선순위 알고리즘 채택시 높은 우선순위의 프로세스가 오는 경우 후순위로 처리된다.
4. 실행 -> 대기 : I/O 요구, 페이지 교환요구 같은 작업에 의해 일어난다. 이러한 작업은 상대적으로 오랜시간이 걸리므로 그 동안 다른 프로세스에 자원을 할당한다.
5. 대기 -> 준비 : I/O 장치 관리자의 신호에 의해 일어난다. 페이지 교환의 경우 페이지 인터럽트 핸들러가 메모리에 페이지가 있다는 신호를 보내면 프로세스는 준비큐에 놓이게 된다.
6. 실행 -> 종료 : 프로세스를 정상 종료하거나 에러발생시 강제종료시 스케줄러에 의해 수행된다.

#### 프로세스 제어 블록

프로세스의 관리를 위해서 운영체제는 각 프로세스 마다 프로세스 제어 블록 (PCB)을 두고 프로세스 정보를 보관한다.

1. 프로세스 상태
2. 프로세스 번호(PID)
3. 프로그램 카운터(PC): 프로세스 수행을 위한 다음명령의 주소 표시
4. 레지스터(register): CPU의 레지스터에 해당하는 정보를 포함한다. 실행상태에서 다른 상태로 전의되는 경우 CPU의 레지스터 정보를 저장하여 나중에 다시 실행상태로 전이될 때 복구하여 프로세스 수행을 계속할 수 있게 한다.
5. 메모리: 프로세스가 저장된 주소와 가상메모리의 가상주소, 실제 주소의 mapping 정보, base register와 bound register 등의 정보를 포함
6. 프로세스 우선순위: 우선순위 스케줄링시 어떤 작업을 선택할 것인지에 대한 정보
7. 회계정보: 성능 측정과 순위에 대한 정보 - CPU 사용시간, 프로세스 존재시간, 메모리사용량 ...

#### 프로세스 생성과 종료

##### 프로세스 생성

프로세스는 프로세스 생성 시스템 호출을 이용하여 어러 개의 프로세스를 호출 할 수 있다.
이 프로세스를 부모 프로세스라 하고, 생성된 새로운 프로세스는 자식 프로세스라 한다.
부모 프로세스는 자식 프로세스에 자원을 나누어 주거나 공유할 수 있다.
물리/논리적 자원을 얻는 것 이외에도 몇몇 초기화 데이터가 부모 프로세스에서 자식 프로세스로 전달된다.

프로세스 생성을 위해서는 프로세스 이름 결정, 프로세스 준비 큐에 삽입, 우선순위 부여, 프로세스 제어블록 생성 등이 필요하다.

##### 프로세스 종료

프로세스는 마지막 문장이 끝났을 때 종료된다. 이때 프로세스는 부모 프로세스에게 실행결과를 되돌려준다.
또한 프로세스가 종료될 때 또 다른 상황이 발생할 수도 있다. (`exit()`와 같은 시스템 호출로 다른 자식프로세스를 종료...)

부모 프로세스는 다음과 같은 이유로 자식 프로세스를 종료할 수 있다.

1. 자식 프로세스가 할당된 자원의 사용 초과 (자식 프로세스의 상태를 검사할 수 있어야 함)
2. 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때

마지막으로 어떤 프로세스가 종료된다면 자식 프로세스는 모두 종료된다 이를 cascading termination 이라하고 OS에 의해 실행된다.

#### 프로세스 간의 관계

##### 독립적 프로세스

independent process란 시스템에서 실행중인 다른 프로세스의 영향을 받지도 주지도 않는 프로세스를 의미한다.
일반적으로 다른 프로세스와 데이터를 공유하지 않는 프로세스는 독립적이다.

1. 프로세스의 상태는 다른 프로세스와 공유되지 않는다.
2. 프로세스의 실행결과는 입력상태에 의해서만 결정된다.
3. 프로세스의 실행은 같은 입력에 대하여 항상 동일하다.
4. 프로세스의 실행은 타 프로세스와 무관하게 중된되거나 재시작될 수 있다.

#### 유기적 프로세스

cooperating process란 실행중인 다른 프로세스와 영향을 주고 받으며 동작하는 프로세스이다.
일반적으로 다른 프로세스와 데이터를 공유하는 프로세스는 유기적 프로세스 이다.

1. 프로세스의 상태는 다른 프로세스와 공유된다.
2. 프로세스의 실행결과는 실행순서에 좌우되므로 미리 예측할 수 없다.
3. 프로세스의 실행결과는 동일한 입력에 대하여 동일함을 보장하지 않는다.

### 쓰레드 (Thread)

일반적으로 다중 프로세싱 시스템에서 기본적 처리단위는 프로세스이다.
하나의 프로그램을 수행하기 위해 하나의 주소공간과 주소공간내에서 하나의 제어흐름으로 구성된 프로세스를 사용한다.
하나의 프로세스 내에서 프로그램이 수행될 때 각각의 실행 단위 시간안에 하나의 실행점만이 존재한다.
즉 단일 프로세스 내에서 동시/병렬 처리가 불가능하다.

쓰레드는 프로세스 내에서 다중처리를 위하여 제안된 개념으로, 실행 단위를 프로세스에서 한 단계 낮추어 규정한 것이다.

기존의 개념에서 프로세스는 자원 소유의 단위와 디스패칭의 단위로 설명될 수 있다.
최근에 개발된 많은 운영체제에서는 디스패칭의 단위를 보통 쓰레드 혹은 경량 프로세스라 하고, 자원 소유의 단위는 그대로 프로세스 또는 작업이라 부르고 있다.

쓰레드는 제어의 흐름을 의미하고 프로세스에서 실행의 개념만을 분리한 것

쓰레드 내에서는 하나의 실행점만 존재하고, 각 쓰레드는 프로그램 카운터와 스택, 쓰레드 관리 정보등과 같은 최소한의 정보만으로 구성된다.
쓰레드도 프로세스와 마찬가지로 생성 후 준비, 실행, 대기 상태를 거친 후 종료상태에 이르게된다.

### 스케줄링

스케줄링이란 여러가지 작업들의 처리순서를 결정하는 것을 의미한다.

#### 스케줄링 단계

##### 상위단계 스케줄링

시스템에 들어오는 작업들을 선택하여 프로세스를 생성한 후 프로세스 준비 큐에 전달

##### 하위단계 스케줄링

사용가능한 CPU를 준비상태의 어느 프로세스에 배당할지를 결정

CPU를 배당받은 프로세스는 실행상태가 된다.
이렇게 프로세스가 준비상태에서 실행상태로 바뀌는 것을 dispatch라 하고, 하위단계 스케줄링의 실행주체는 dispatcher가 된다.

하위 단계 스케줄링은 빈번하게 일어나므로 dispatcher는 메모리에 상주해야 한다.

##### 중간단계 스케줄링

프로세스를 일시적으로 메모리에서 제거하여 중지 시키거나 다시 활성화 시켜서 시스템에 대한 단기적 부하를 조절한다.

#### 스케줄링 정책

운영체제의 목적(처리량 극대화, 반환시간 최소화, CPU 활용의 극대화, 빠른 응답시간 ...)에 맞춰 프로세스에게 자원을 할당한다.

##### 선점 스케줄링 정책 (preemptive scheduling policy)

진행 중인 작업에 인터럽트를 걸고 다른 작업에 CPU를 할당하는 스케줄링 전략이다.
선점 스케줄링 방식은 시간 할당 방식에서 주로 사용된다.

높은 우선순위의 프로세스가 긴급한 경우 유용하다. 또한 필요 프로세스가 자원을 선점하므로 예측가능하다.
하지만 프로세스를 종료하지 않은채 자원을 다른 프로세스에 할당하려면 문맥교환이 필요하므로 오버헤드가 발생한다.

문맥교환(context switching)이란 CPU가 현재 실행하고 있는 프로세스의 context를 프로세스 제어블록(PCB)에 저장하고,
다음 프로세스의 PCB로 부터 context를 복원하는 작업을 의미한다.

##### 비선점 스케줄링 정책 (nonpreemptive scheduling policy)

프로세스가 CPU를 할당받아 실행이 시작되면 프로세스 자체가 I/O 인터럽트를 걸거나 프로세스를 종료할 때 까지
(예외적으로 무한루프를 숭해중인 경우 선점/비선점에 관계없이 인터럽트가 걸린다) 실행상태에 있게 된다.

우선순위에 관계없이 대기 중인 프로세스는 변동이 없으므로 응답시간 예측이 가능하다.

## 스케줄링 알고리즘

### 스케줄링 성능 평가 기준

평균 대기시간:
각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간합의 평균

평균 반환시간:
각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균

### FCFS 스케줄링

First Come First Served 스케줄링은 비선점 방법이다.

프로세스는 준비 큐에서 도착순서에 따라 디스패치되며,
일단 한 프로세스가 CPU를 차지하면 그 프로세스의 수행이 완료된 후에 다음 프로세스가 수행된다.

| 프로세스 | CPU사이클 |
|---|---|
| A | 6 |
| B | 3 |
| C | 1 |
| D | 4 |

4개의 프로세스가 A B C D 순서로 거의 동시에 입력되었다면 FCFS 스케줄에서 실행순서는

1. 0~6: A
2. 6~9: B
3. 9~10: C
4. 10~14: D

평균 대기시간: (0+6+9+10)/4 = 6.25

평균 반환시간: (6+9+10+14)/4 = 9.75

FCFS 알고리즘은 짧은 작업이 긴 작업을 기다리기도 하고 중요한 프로세스가 나중에 수행될 수도 있다.
또한 프로세스들의 도착 순서에 따라 평균 반환시간이 크게 변하는 단점도 있다. 따라서 대화형 시스템에 사용하지 않는다.

최근 시스템에서 FCFS 스케줄링은 주요 방법이 아니라 다른 방법과 결합하여 쓰이고 있다.

### SJF 스케줄링

SJF(Shortest Job First) 스케줄링은 준비큐에서 기다리는 프로세스 중
실행시간이 가장 짧다고 예상된 것을 먼저 디스패치 하여 실행하는 비선점 스케줄링 알고리즘이다.

| 도착시간 | 프로세스 | CPU사이클 |
|---|---|---|
| 0 | A | 6 |
| 1 | B | 3 |
| 2 | C | 1 |
| 3 | D | 4 |

1. 0~6: A
2. 6~7: C
3. 7~10: B
4. 10~14: D

평균 대기시간: (0+6+4+7)/4 = 4.25

평균 반환시간: (6+9+5+11)/4 = 7.75

SJF 스케줄링 알고리즘의 문제점은 실행 예정 시간 길이를 사용자의 추정치에 의존하므로
실제로 먼저 처리할 작업의 CPU 시간을 에상할 수 없다. 따라서 대화형 시스템에 사용 하지 않는다.

### SRT 스케줄링

SRT(Shortest Remaining Time) 스케줄링은 SJF 알고리즘의 선점(preemptive) 알고리즘 버전이다.
새로 들어오는 프로세스를 포함하여 실행이 끝날 때까지 남은 시간 추정치가 가장 짧은 프로세스를 먼저 디스패치한다.
대화형 운영체제에서 유용한 방식이다.

| 도착시간 | 프로세스 | CPU사이클 |
|---|---|---|
| 0 | A | 6 |
| 1 | B | 3 |
| 2 | C | 1 |
| 3 | D | 4 |

1. 0~1: A
2. 1~2: B
3. 2~3: C
4. 3~5: B
5. 5~9: D
6. 9~14: A

평균 대기시간: (8+1+0+2)/4 = 2.75

평균 반환시간: (14+4+1+6)/4 = 6.25

SRT는 SJF보다 평균 대기시간이나 평균 반환시간면에서 효율적이다.
하지만 SRT는 실행되는 각 작업을 추적하여 서비스를 받은 시간이 기록되어야 하며
선점을 위한 문맥 교환도 필요하므로 SJF보다 오버헤드가 크다.

이러한 상황은 임계치(threshold value)를 설정하여 해결하는데,
만일 실행중인 작업이 완료되기까지 남은 시간이 임계치 보다 작다면 시스템은 그 작업을 계속 실행하게 하는것이다.

### RR 스케줄링

RR(Round Robin) 스케줄링은 대화형 시스템에서 사용되는 선점 스케줄링 방식이다.
프로세스가 도착한 순서대로 프로세스를 디스패치 하지만 정해진 시간 안에 완료하지 못한 프로세스는 다시 준비큐의 맨 뒤에 배치한다.

| 도착시간 | 프로세스 | CPU사이클 |
|---|---|---|
| 0 | A | 6 |
| 1 | B | 3 |
| 2 | C | 1 |
| 3 | D | 4 |

시간 할당량을 3으로 둔다면

1. 0~3: A
2. 3~6: B
3. 6~7: C
4. 7~10: D
5. 10~13: A
6. 13~14: D

평균 대기시간: (7+2+4+7)/4 = 5

평균 반환시간: (13+5+5+11)/4 = 8.5

RR스케줄링 알고리즘의 성능은 평균 CPU 소요시간에 대한 시간간격의 길이에 따라 달라진다.
간격이 너무 큰경우에는 FCFS 정도로 성능이 낮아질 것이다.
간격이 너무 짧은 경우 잦은 문맥 교환이 작업 수행을 방해하여 오버헤드가 크게 증가한다.

따라서 가장 적절한 시간 간격은 시스템 형태에 따라 최적화 되어야 한다.

적절한 시간 간격을 결정하는 데는 일반적인 규칙 두 가지가 있다.
첫째, 80%의 CPU 사이클을 처리할 수 있또록 하는 것. 둘째, 한 번의 문맥 교환에 걸리는 시간보다 100배 정도는 길어야 한다.

### HRN 스케줄링

HRN(Highest Response Ratio Next) 스케줄링은 준비 큐에서 기다리는 프로세스 중
응답비율이 가장 큰 것을 먼저 디스패치 하여 실행하는 비선점 스케줄링 알고리즘이다.

`응답비율 = (대기시간 + 예상 실행시간) / 예상 실행시간 = 대기시간/예상실행 시간 + 1`

| 도착시간 | 프로세스 | CPU사이클 |
|---|---|---|
| 0 | A | 6 |
| 1 | B | 3 |
| 4 | C | 2 |
| 6 | D | 1 |

1. A 실행: 응답비율 = (0+6)/6 =1
2. A 실행 중 B((5+3)/3=2.67), C((2+2)/2=2), D((0+1)/1 = 1) 도착
3. 응답비율이 큰 B를 실행
4. 응답비율이 큰 D를 실행
5. 마지막으로 C를 실행

HRN 스케줄링은 SJF 스케줄링의 단점을 보완한 것이다.
HRN 스케줄링은 실행시간이 긴 프로세스라 하더라도 대기시간이 길어지면 응답비율도 커져서
실행시간이 짧은 프로세스가 들어오더라도 우선순위에서 밀리지 않을 수 있다.

### 다단계 피드백 큐 스케줄링

다단계 피드백 큐 스케줄링은 선점 스케줄링 방식으로,
입출력 중심인 프로세스와 CPU 중심인 프로세스의 특성에 따라 서로 다른 시간 할당량을 부여한다.

다단계 피드백 큐 스케줄링은 n개의 단계가 있는경우, 각 단계마다 하나씩의 큐가 존재한다.
단계 `k`는 단계 `k+1`에 피드백을 주며 단계가 커질수록 시간 할당량은 커지는 형태로 구성되어 있다.

프로세스가 도착하면 단계 1의 큐에 들어간다.
이후 큐에 도착한 순서대로 프로세스들이 처리되다가 자신의 차례가 되면 해당 프로세스는 디스패치 되어 단계 1의 시간할당량 만큼 실행된다.

시간할당량보다 짧은 시간에 프로세스가 끝나면 완료가 되고, 입출력 같은 이벤트가 발생하면 CPU를 양보하고 대기상태로 갔다가
다시 준비상태가 될 때에는 현재와 동일한 단계의 큐에 배치된다.
만약 시간 할당량을 다 썼지만 프로세스가 종료되지 못했다면 다음단계 큐로 이동 배치된다.

반복하여 마지막 단계 n에서도 단계 n의 시간 할당량만큼 실행한 후 종료되지 못한경우에는 계속하여 동일한 단계 n의 큐에 배치된다.
마지막 단계만 보면 RR 스케줄링 방식과 동일하다.

결국 연산 위주의 프로세스는 점점 단계가 커지게 되고, 입출력 위주의 프로세스는 앞부분의 단계를 유지하게 된다.

다단계 피드백 큐 스케줄링 알고리즘의 변형으로 적응적 스케줄링 기법을 적용할 수 있다.
이는 프로세스의 유동적 상태 변화에 적응한다는 의미로,
기본적으로 동일한 프로세스는 마지막에 있었던 단계의 큐로 배치가 되고 한 번 단계가 커지면 반대로 돌아갈 방법이 없지만,

적응적 기법에서는 시간 할당량을 다 쓰기 전에 CPU를 반납하는 경우 하나 작은 단계의 큐로 되돌아 갈 수 있다.
따라서 연산 위주의 작업을 하던 프로세스는 큰 단계에 배치되지만, 이후 프로세스의 성격이 입출력 위주로 바뀐다면 점점 작은 단계로 배치될 수 있다.

## 병행 프로세스

### 병행 프로세스의 개념

#### 병행성(concurrency)

병행성은 여러 개의 프로세스 또는 쓰레드가 동시에 실행되는 시스템의 특성을 의미한다.

병행 프로세스가 실행되는 형태는 CPU 개수에 따라 차이가 있다.
하나의 CPU에서 병행 프로세스가 실행되는 경우에는 각 프로세스가 짧은 시간 간격으로 번갈아 실행되는 인터리빙 형식으로 실행된다.
정확히 한 순간에는 하나의 프로세스가 실행되지만, 전체적으로 보면 어러 프로세스가 동시에 실행되는 병행성을 보인다.

여러개의 CPU에서 병행 프로세스가 실행되는 경우에는 각 CPU에서 온전히 실행되어 병렬 처리 형식으로 실행된다.

여러개의 CPU에서 병행 프로세스가 실행되는 경우에도 메모리 구조에 따라 차이가 있다.

강결합(tightly coupled) 멀티 프로세서 시스템에서는 여러 CPU간에 하나의 기억장치를 공유하며 하나의 운영체제가 모든 CPU와 시스템 하드웨어를 제어한다.
강결합 시스템에는 master/slave 환경이나 Symmetric Multiprocessing이 해당된다.

약결합(loosely coupled) 멀티 프로세서 시스템에서는 2개 이상의 독립된 컴퓨터 시스템을 통신선을 통하여 연결한다.
각 시스템안 자신의 운영체제와 기억장치를 가지고 있으며 독립적으로 운영되고 필요할 때 통신을 한다.
시스템간의 통신은 메시지 전달이나 원격 프로시져 호출방식(remote procedure calls)을 사용한다.
약결합 시스템에는 클러스터 구조가 해당한다.

#### 단일 프로세스 내의 병행성

##### 우선순위 그래프

우선순위 그래프란 각 정점이 개개의 문장에 대응하는 사이클이 없는 방향 그래프이다.

```text
S1: a := x + y;
S2: b := z + 1;
S3: c := a + b;
s4: write(c);
```

위와 같은 경우

1. S3은 S1과 S2가 완료된 후에 실행될 수 있다.
2. S4는 S3이 완료된 후에 실행될 수 있다.
3. 따라서 S1과 S2는 동시에 실행될 수 있다.

##### Fork/Join 구조

fork {label} 명령어는 프로그램 내에서 2개의 병행 수행을 만들어 낸다.
하나는 label이 붙여진 문장에서 수행을 시작하고 다른 하나는 fork 명령어 다음 문장을 계속 수행한다.

join 명령어는 병행하는 2개의 연산을 하나로 재결합시키는 방법을 제공하며 2개의 연산은 서로 결합되도록 요청해야 한다.
3개의 연산이 결합될 경우에는 join을 실행하는 처음의 2개가 종료되어도 세 번째 연산은 계속되어야 한다.
마지막 하나를 제외하고 나머지는 모두 종료시킬 수 있도록 결합될 연산의 수를 알아야 한다.
따라서 join 명령어는 결합할 join의 수를 알아내는 매개변수를 갖는다.

fork/join 구조는 다중 쓰레드 프로그래밍을 할 때 주로 이용된다.

##### 병행문

1개의 프로세스가 여러 가닥의 병렬 프로세스로 분할되었다가 다시 한 가닥의 프로세스로 결합하는 것을 나타내기위해서 병행문을 사용한다.

`parbegin S1; S2; ... Sn; parend`

Si는 단일 문장이고 parbegin고 parend 사이에 있는 모든 문장은 병행하여 수행될 수 있다.

#### 프로세스 간의 병행성

프로세스간 병행성에서 상호 협력하는 경우를 비동기적(asynchronous)이라고 하며 때때로 자원을 공유하므로 복잡하다.

비동기 병행 프로세스는 어떤 프로세스가 실행중인 다른 프로세스에 영향을 주는 유기적 프로세스가 된다.
이로 인하여 동기화 문제가 발생할 수 있다.

### 동기화와 임계영역

프로세스 동기화는 2개 이상의 프로세스에 대한 처리순서를 결정하는 것을 말한다.
동시에 사용할 수 없는 공유자원이 있는 경우 프로세스 동기화 성공여부는
하나의 자원이 사용되는 동안에 다른 프로세스에서는 사용 불가능하게 만드는 운영체제에 달려있다.

프로그램에서 각 프로세스는 임계영역(critical section)이라 불리는 코드 세그먼트를 갖는데,
이 세그먼트에서 프로세스는 공용변수를 읽고, 테이블을 갱신하고, 파일에 쓰는 등의 일을 한다.

시스템의 가장 중요한 특징은 하나의 프로세스가 임계영역에서 수행 중일 때
다른 어떠한 프로세스도 이 임계영역에서 수행될 수 없다는 것이다.

임계영역을 갖는 프로세스의 일반적 구조는 다음과 같다.

- 진입영역: 각 프로세스는 그 임계 영역에 들어갈 수 있는지의 여부를 미리 요청
- 해제영역: 임계영역의 수행을 마치고 다음에 진입할 프로세스를 선택함
- 잔류영역: 임계영역을 마치고 나와서 나머지 작업을 수행

임계 영역 문제의 해결에 있어서는 다음의 세 가지 요구가 만족되어야 한다.

1. 상호배제: 프로세스 Pi가 임계영역에서 수행 중일 때 다른 어떤 프로세스도 임계영역에서 수행될 수 없다.
2. 진행: 임계영역에서 수행되는 프로세스가 없고 여러 프로세스가 임계영역에 들어오고자 할 때, 그중에서 다음에 임계영역에서 실행할 대상을 결정해야 하며 결정은 무한정 미루어질 수 없다.
3. 제한된 대기: 한 프로세스가 임계영역에 대한 요청 후 부터 요청이 수락되기 까지의 기간 내에 다른 프로세스가 임계영역을 수행할 수 있는 횟수에는 제한이 있어야 한다.

동기화는 때때로 절대영역에서 일할 수 있는 프로세스에 앞서 'lock-and-key'를 실행한다.
일단 키를 가지면 절대영역에 들어간 프로세스가 일을 마치고 키를 반환할 때까지 모든 다른 프로세스는 잠기게 된다.

이런 구조는 동시에 행위를 취해야 하며 단일 기계 사이클에서 이루어져야 하는데, 수행방법에는 여러 종류가 있다.
Test and Set 과 세마포어(semaphore)가 이러한 수행방법이다.

#### Test-and-Set

상호배제의 하드웨어적 해결방법으로 분리가 불가능한 단일 기계 명령어로서, 간단히 'TS'라고 한다.
단일 기계사이클로 동작하여 프로세서는 lock을 사용할 수 있는지 여부를 확인한 후 사용할 수 있으면 '사용할 수 없음'으로 세팅한다.

Test-and-Set은 두 가지의 결점을 가지고 있다.
첫째, 많은 프로세스가 절대 영역에 들어가기를 원할 때 starvation이 발생하는데, 프로세스가 임의접근을 시도하기 때문이다.
FCFS 정책이 정해지지 않는다면 어떤 프로세스가 실행되지 못할 수도 있다.
둘째, 대기 프로세스는 비생산적이고 자원만을 소비하는 busy waiting이 발생한다.

#### 세마포어

세마포어의 가장 잘 알려진 예는 철도에서 열차의 진행 가능 여부를 나타내는 신호기이다.
신호기가 올라가면 장애물이 있다는 표시로 열차는 신호기가 내려갈 때까지 기다려야 한다.

세마포어 s는 정수값을 가지며 두 표준 단위연산 P(검사)와 V(연산)에 의해서만 접근되는 정수형 공용변수이다.

```text
P(s):
  if (s > 0) then
    s :- s-1;
  else
    현재프로세스 대기;

V(s):
  if (1개 이상의 프로세스가 대기중) then
    그중 1개의 프로세스만 진행;
  else
    s := s+1;
```

### 프로세스의 상호협력

#### 생상자/소비자(producers/consumers) 문제

생산자/소비자 문제는 유한 버퍼(bounded buffer) 문제라고도 한다.

고정된 크기의 버퍼를 사이에 두고 버퍼가 비어있다면 소비자가 기다리게 되고 버퍼가 가득 차면 생산자가 기다리게 된다.
이는 상호배제(한 순간에 한 프로세스만이 버퍼를 사용해야 하고)와 동기화(생산이 이루어져야 소비가 가능하고, 버퍼 용량 이상을 생산하면 안됨)가
해결되어야 하며, 세마포어를 이용하여 구현한다.

#### 판독기/기록기 문제

대이터 객체는 여러 병행 프로세스 간에 공유될 수 있다.
프로세스 중의 일부는 다른 것이 공유객체의 내용을 읽기 원할 때, 공유 객체의 갱신(읽기/쓰기)을 원할 수 있다.
읽고자 하는 프로세스는 판독기(reader), 쓰고자 하는 프로세는 기록기(writer)라고 구분한다.

기록기와 또다른 프로세스가 동시에 공유객체에 접근한다면 병행성 조건을 침해하게 된다.
따라서 기록기가 공유객체에 대해 배타적으로 접근하도록 해야 한다.

제1 판독기/기록기 문제는, 어떠한 판독기도 기록기가 대기중이라는 이유로 다른 판독기가 끝나기를 기다리지 않는다.
제2 판독기/기록기 문제는, 일단 기록기가 준비되었다면 기록을 가능한 빨리 수행할 수 있도록 하는 것이다.
두 문제에 대한 모든 해답이 starvation을 발생시킬 수 있음을 주의해야 한다.

### 프로세스 간의 통신

동기화 문제를 큰 각도로 보면 협력하려는 프로세스 간의 통신을 허락하는 문제로도 볼 수 있다.

#### 공유 기억장치 기법

통신하는 프로세스 간에 변수를 공유하도록 하여 프로세스가 공유변수를 이용하여 정보를 교환하도록 하는 것으로, 유한 버퍼가 한 예이다.

#### 메시지 시스템 기법

프로세스 P와 Q가 통신하기를 원한다면 서로 메시지를 주고받아야 한다.
이를 위한 통신링크는 여러 방법으로 구현될 수 있다.

##### 직접 통신

직접 통신 기법에서는 메시지를 주고받기 원하는 각각의 프로세스는 수신자나 전송자의 이름을 명시해야 한다.

1. 통신을 원하는 모든 프로세스의 쌍 사이에 링크가 자동으로 설정된다.
2. 프로세스는 통신하기 위하여 서로 상대방의 신원을 알아야 한다.
3. 하나의 링크는 두 프로세스 사이에만 연관된다.
4. 각 통신 프로세스 쌍 사이에는 정확히 하나의 링크가 존재한다.
5. 링크는 양방향이다.

직접 통신의 단점은 프로세스의 이름을 바꾸려면 다른 모든 프로세스의 정의를 조사해야 한다는 점이다.

##### 간접 통신

간접 통신을 통해 우편함으로부터 메시지를 보내거나 받을 수 있다.
우편함은 프로세스에 의해 메시지가 넣어지고 빠지는 객체로 취급할 수 있다.
각 우편함은 유일한 이름을 갖고 프로세스는 서로 다른 우편함에 의하여 다른 프로세스와 통신할 수 있다.

1. 공유 우편함이 있는 경우에만 프로세스 쌍 사이에 링크가 설정된다.
2. 한 링크는 2개 이상의 프로세스들과 연관될 수 있다.
3. 각 통신 프로세스 쌍 사이에는 몇 개의 다른 링크가 있을 수 있으며, 각각은 서로 다른 우편함과 교신한다.
4. 링크는 단방향이거나 양방향일 수 있다.

우편함은 프로세스나 시스템에 소속될 수 있다.
우편함이 프로세스에 소속될 때는 우편함의 소유자와 사용자를 구별한다.
우편함을 소유하고 있는 프로세스가 종료되면 우편함은 없어진다.
따라서 우편함에 메시지를 송신하는 모든 프로세스에게 더 이상 우편함이 존재하지 않는다는 것을 알려주어야 한다.

운영체제가 소유하는 우편함은 스스로 존재힌다. 독립적이며 어떤 프로세스에 속하지 않는다.

##### 링크의 용량

링크는 임시로 저장되는 메시지의 수를 결정하는 용량을 갖는다.
이런 특성은 링크에 붙여지는 메시지의 큐로써 생각될 수 있다.

1. 0용량: 링크는 어떠한 메시지도 가질수 없으므로 송신자는 수신자가 메시지를 수신할 때 까지 기다려야한다.
2. 제한된용량: 큐가 차있지 않다면 세로운 메시지는 큐에 들어간다. 링크가 꽉차면 송신자는 큐에 공간이 생길때까지 기다려야 한다.
3. 무제한용량: 송신자는 기다리는 경우가 없다.

0용량이 아닌경우 송신자는 메시지 전달여부를 알기 위하여 수신자와 통신을 해야 한다. 이런경우 프로세스는 비동기적으로 통신한다고 한다.

##### 예외조건

메시지 시스템은 분산환경에 유용한데 이런경우 통신과 처리의 오류가 발생할 확률은 단일 시스템 보다 높다.

시스템이 메시지 처리 방법에서 취급해야 할 예외조건들

1. 프로세스 종료: 송신/수신 프로세스는 메시지가 처리되기 전에 긑날 수 있다.
2. 메시지 상실: 프로세스간 메시지 전송 중 하드웨어나 통신장애로 상실 될 수 있다.
3. 메시지 혼합: 메시지는 배달되는 도중 뒤섞일 수 있다(잡음...), 오류 탐지를 사용한다.(checksum...)
