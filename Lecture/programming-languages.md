# 프로그래밍 언어론

## 프로그래밍 언어란

프로그래밍 언어는 컴퓨터에 프로그래머의 의사를 전달하는 방법이며, 동시에 프로그램을 작성하는 형식이다.

프로그래밍 언어는 컴퓨터 구조의 추상화이기도 하다.
변수는 기억장치를, 연산자는 CPU를 추상화한 것이라 할 수 있다.

## 프로그래밍 언어의 구조 및 해석

### 언어구문

컴퓨터 내부에서는 7비트로 구성된 ASCII 코드를 일반적으로 사용한다.
이후 각 국가의 문자코드에 대응한 문제를 해결하기 위해 16비트 유니코드 체계가 도입되었다.

프로그래밍 언어의 어휘구조는 프로그래밍 언어 알파벳 문자로 구성된 어휘토큰이다.

번역기는 어휘분석 단계에서 입력 프로그램의 일련의 문자를 토큰으로 구분하고,
구문분석 단계에서 이를 처리하여 구문구조를 결정한다.

한 개 이상의 어휘 토큰을 가지고 구문적으로 허용된 프로그램의 일부구조를 언어 구성자(식별자)라고 한다.
프로그래밍 언어는 일부 식별자를 미리 정의하여 사용한다.
미리 정의된 식별자 중에서 재정의 할 수 없도록 한 식별자를 예약어(reserved word)라고 한다.

예약어를 사용함으로써 프로그램을 읽기 쉽도록 하고,
컴파일러가 기호 테이블을 짧은 시간에 탐색하도록 해주며, 오류 검색시간을 줄여준다.

#### 문맥 자유 문법과 BNF

```text
<identifier> ::= <letter> | <identifier> <letter> | <identifier> <digit>
<letter> ::= A | B | C | ... | X | Y | Z
<digit> ::= 0 | 1 | 2 | ... 8 | 9
```

- 비단말(nonterminal) 기호: `<foo>`: BNF 규율로 다시 정의될 대상
- 단말(terminal) 기호: `foo`: 각 언어에서 사용하는 알파벳 문자 집합과 예약어
- 메타기호(meta symbol): `::=`, `|`, `<>`: 언어를 표현하기 위해 사용한 특수기호

모든 생성규칙에서 정의될 대상이 하나의 비단말 기호만으로 구성된다면 그 문법을 문맥자유 문법이라고 한다.
즉, 각 비단말기호가 어디에 나타난다 해도 그에 해당되는 오른쪽 선택으로 언제나 대치될 수 있음을 뜻한다.

특수한 문맥에 의존하여 대치되는 문법을 문맥의존 문법이라고 한다.

#### EBNF

BNF 표기법으로 모든 프로그래밍 언어를 표기할 수 있지만 보다 간결하게 표현할 수 있는 EBNF를 사용하기도 한다.
EBNF는 특수한 의미를 갖는 메타 기호를 더 사용하여 반복되는 부분이나 선택적인 부분을 간결하게 표현할 수 있다.

반복되는 부분은 `{ }`를 사용하여 나타낸며, 선택적인 부분은 `[ ]`를 사용하여 나타낸다.

예를 들어 영문자로 시작하고 최고 8개의 문자를 가질 수 있는 식별자를 EBNF로 표기하면 다음과 같다.

```text
<identifier-name> ::= <letter> {<alphanumeric>}70
<alphanumeric> ::= <letter> | <digit>
<letter> ::= A | B | C | ... | X | Y | Z
<digit> ::= 0 | 1 | 2 | ... 8 | 9
```

반복표기뒤의 두 숫자는 최대(7)와 최소(0)을 나타낸다.

메타기호를 단말기호로 나타낼 때의 혼동을 피하기 위해서 `단말기호: '메타기호'`와 같이 사용한다.

#### 구문도표

구문도표에서 다시 정의될 대상은 사각형으로 표시하고,
단말기호는 원이나 타원으로 표시하고, 비단말 기호는 사각형으로 표시한다.
이들의 사이는 지시선으로 연결한다.

#### Parse Tree

한 표현이 주어진 BNF에 의하여 작성될 수 있는지를 확인하기 위해,
대상을 root로 하고 단말노드를 왼쪽에서 오른쪽으로 나열한 것이 검증하고자 하는 표현과 같은 트리이다.

Parse Tree에서 불필요한 비단말기호를 없애면 (추상)구문 트리라 한다.

그러나, 하나의 BNF식이 두 가지 이상의 Parse Tree로 유도되는 경우 모호성을 갖게된다.
모호성을 갖는 경우 문법을 모호함이 없도록 개정하거나 모호성 제거규칙을 기술해야 한다.

dangling else 문제 ...

### 프로그래밍 언어 구현 기법

#### 컴파일 (Compile)

컴파일러는 source 언어(고급/저급언어)로 작성된 프로그램을 입력받아 object 언어(고급/저급언어)로 된
기능이 동등한 프로그램을 출력해주는 언어처리기이다.

그러나 일반적인 의미에서 컴파일러는 고급 프로그래밍 언어로 작성한 프로그램을 실제 컴퓨터의 기계어로 번역하여
동등한 의미의 기계어 프로그램을 만들어 실행시키는 방법을 지칭한다.

- 컴파일러(compiler): 원시언어를 목적언어(일반적으로 준기계어: relocatable form)로 만들어주는 번역기
- 어셈블러(assembler): 원시언어가 어셈블리 언어인 번역기, 어셈블리 명령어 하나당 하나의 기계어 명령으로 단순번역됨
- 링커(linker): relocatable form으로 구성된 여러 개의 프로그램(컴파일된 목적코드와 라이브러리)을 묶어서, 로드모듈이라는 어느정도 실행가능한 하나의 기계어로 번역해주는 번역기
- 로더(loader): 로드 모듈로 된 기계어 프로그램을 실제 실행 가능한 기계어로 번역해서 주 기억장치에 적재함
- 프리프로세서(preprocessor): 원시언어와 목적언어가 모두 고급언어인 번역기

순서: {고급언어 - 컴파일러 - 목적모듈} - 링커(다수의 목적모듈을 연결) - 로드모듈 - 로더 - 기계어

#### 인터프리트 (Interpreted)

인터프리터가 고급언어로 된 프로그램을 입력받아 기계어 수행과 동일한 알고리즘으로
프로그램의 각 문자을 디코딩하고 실행시킴으로써 고급 언어를 시뮬레이션 하는 것

순서: 고급언어 프로그램 - 인터프리터 - 실행 결과

#### 컴파일 기법과 인터프리트 기법의 비교

컴파일러는 프로그램의 각 문장을 입력된 순서대로 한 번씩 처리하여 효율적인 목적 코드를 생성하지만,
인터프리터는 프로그램의 논리적 순서에 따라 문장을 실행하기 때문에 반복 처리되는 부분이 있다.

많은 경우 프로그래밍 언어는 컴파일 기법과 인터프리트 기법을 함께 사용하여 구현된다.
이러한 구현기법을 중간 코드 실행기법이라고 한다.

## 변수, 바인딩, 식, 제어문

### 변수 (variable)

변수란 선언문 또는 묵시적 선언으로 생성되며, 식별자, 자료속성의 집합, 하나 이상의 주소, 자료값
네 가지 요소로 구성되는데, 주소와 자료값의 관계는 변할 수 있다.

### 바인딩 (binding)

이름에 어떤 속성을 연결하는 과정을 바인딩(binding)이라고 한다.

속성이 이름에 연결되고 계산되는 과정이 어느 시점에서 이루어지는가에 따라 바인딩을 분류할 수 있는데,
그 시간을 바인딩 시간(binding time)이라 한다.

#### 바인딩 시간 (binding time)

바인딩 시간에는 크게 정적 바인딩(static binding)과 동적 바인딩(dynamic binding) 개념이 있다.

- 실행시간
  - 바인딩은 대부분 프로그램 실행시간 중에 이루어지는 동적바인딩이다
  - 모듈의 시작시간: 많은 프로그래밍 언어에서 중요한 바인딩이 모듈 프로그램(블록) 실행 시작시간에 발생한다
  - 실행시간의 사용시점: 프로그램을 실행하는 동안 사용시점에서 수시로 발생하는 바인딩이 있다

- 번역시간
  - 컴파일 언어에서는 대부분의 중요한 바인딩이 번역시간(translation time)에 수행된다
  - 컴파일 언어는 대부분 정적 바인딩을 기본으로 한다
  - 번역시간: 컴파일시간, 링크시간, 로드시간으로 구성된다

- 언어 구현시간
  - 프로그래밍 언어의 구성자에 관한 많은 특성을 구체적으로 한정하지 않고 프로그램을 작성할 때에 특성의 일부를 확정하도록 일임하고 있다.

- 언어의 정의시간
  - 프로그래밍 언어에서 허용되는 자료구조, 프로그램 구조 등에 관한 것은 언어 설계시 확정된다
  - 대부분의 언어에서는 언어의 정의시간 바인딩을 많이해서 언어의 구현시간에 일어나는 바인딩을 최소화 한다

### 선언 (declaration)

선언이란 실행 시 사용할 자료의 속성을 컴파일러 등에 알려주는 프로그램 문장으로, 바인딩을 제공하는 중요한 방법이다.

많은 프로그래밍 언어에서 명시적 선언이 없으면 묵시적 선언(default declaration)으로 간주한다.

자료의 속성에는 자료형, 크기, 이름, 생성시기, 소멸시기, 참조하는 첨자등이 있다.

```java
int[] arr = new int[30];
```

이 선언문은 배열 `arr`의 생성과 소멸 시기, 자료형, 원소의 수, 첨자값의 사용범위(0~29), 각 원소의 자료형, 참조할 배열이름 (arr) 등을 한정하는 선언문이다.

프로그래밍 언어에서 선언문은 다음과 같은 목적을 달성한다.

- 주기억장치 사용과 접근방법의 효율성
  - 프로그램 실행동안 변하지 않는 자료구조의 속성을 한정한다
  - 이러한 정보로 컴파일러는 기억장치 안에서 표기와 자료구조에 접근하는 계산을 최적화 할 수 있다

- 주기억장치 구동 효율
  - 선언에 따라 제공되는 자료구조 속성을 알게됨으로써 실행시간동안 보다 효율적인 기억장소 할당기법을 제공
  - 인터프리터 언어에서는 보다 복잡하고 비효율적으로 주기억장치를 사용한다

- Static type checking
  - type specific operation: 주어진 연산자에 대해 피연산자와 연산결과의 자료형이 고정되지 않은 연산
  - mixed operation: 주어진 연산자에 대한 피연산자와 연산결과의 자료형이 고정되지 않은 연산
  - 고급 프로그래밍 언어에서는 대부분 구현시간에 혼합형 연산을 사용할 수 있지만, 컴파일 타임에 목적코드의 타입은 고정된다

### 할당문 (assignment statement)

할당문은 변수의 내용을 변경할 수 있는 연산이며, 프로그램에서 가장 일반적으로 나타나는 연산문이다.

할당문을 위한 연산자는 다양하게 사용된다: `S = T`, `S := T`, `S <- T`, `LET S = T`, `MOVE T TO S`

- 단순 할당문: `<목적지변수> <할당연산자> <식>`
- 다중 목적 변수 할당문: `W, X ,Y = o`
- 조건 목적 변수 할당문: `flag ? n : m = o`
- 복합할당 연산자: `s = s + t`
- 단항할당 연산자: `t = ++s`, `t = s++`
  - 두 개의 단항 연산자가 동일한 피연산자에 적용될 경우 오른쪽부터 적용: `-s++` == `-(s++)`

할당문은 식으로 혹은 다른 식에 포함된 피연산자로 사용될 수 있다.

`while((s= getchar()) != "\n") { ... }`

할당문 양편에 자료형이 서로 다를 때 혼합형 할당문이라고 한다.

두 형이 일치하지 않는 경우에는 묵시적 형 변환의 사용여부가 고려사항이다.
혼합형 할당문을 허용하는 모든 언어에서 묵시적 형 변환은 오른쪽 식이 평가된 후에 일어난다.

### 상수 및 변수 초기화

변하지 않는 값을 갖는 변수의 사용을 지원하기 위해 상수라는 개념이 존재한다.

상수를 나타내는 이름에 실수로 어떤 값을 재할당 하는 경우 컴파일러가 이를 인식할 수 있으므로,
프로그램의 신뢰성이 증가한다.

### 표현식 (expression)

표현식은 하나 이상의 피연산자를 가지고 자료값의 계산을 기술하는 것이다.

식은 상수나 변수 같은 피연산자, 연산자, 그리고 사용가능한 함수호출(function call)로 구성된다.

식 평가는 피연산자 값에 대하여 주어진 연산을 실행함으로써 이루어진다.

한 프로그램에서 사용되는 모든 변수와 관련 있는 값은 program state space 또는 program environment를 형성한다.
이러한 환경을 변화시키지 않고 오직 값만 생성하는 것이 참조 투명성(referential transparency)이다.

그러나 대부분의 프로그래밍 언어에서는 식에 사용된 함수가 변수값을 변경시켜서 환경을 변화시킬 가능성이 존재한다.

식에서 피연산자와 연산자의 결합순서도 중요하다. (언어별로 연산자 우선순위가 다르다)

일반적으로 여러 피연산자가 있는 식의 평가는 피연산자를 평가한 후 연산자를 적용하여 결과를 얻는다.
이러한 방식을 평가의 적용순서(applicative order)라 한다.

그러나 논리 연산자는 하나의 피 연산자 값만을 알고도 그 식의 값을 알 수도 있다.
이를 위해 언어 내부에 단락회로(short circuit) 평가기법을 도입했다.

### 조건문 (conditional statement)

조건문은 조건에 따라 실행되는 부분이 달라질 때 사용하는 문장이다.

널리 사용되는 조건문으로는 `if elseif else`문과 `switch case`문이 있다.

### 반복문 (iteration statement)

반복문은 하나 이상의 문장을 0번 이상 반복하여 실행시키는 문장이다.

함수형 언어에서는 반복을 재귀호출로 수행한다.

- 사용자 지정 반복: 반복 수행을 하려는 일련의 문장을 묶어 의도한 횟수로 반복한다
  - `break`, `exit`: 반복문을 벗어난다
  - `continue`: 작은 반복구간을 가진다 (다시 루프의 처음으로 돌아감)

- 논리제어 반복문: 반복문은 초기 조건검사를 하고 그 결과가 참이면 반복문을 수행한뒤 다시 조건검사를 행한다

- 제어변수 반복문: `for`문과 같이 제어변수를 사용하여 고정된 횟수의 반복을 표시한다

## 자료형

### 자료형과 형 선언

자료형이란 객체(object)의 집합과 이 객체의 실체(instance)를 생성, 작성, 소멸, 수정, 분해 하는 연산의 집합을 말한다.

명령형 프로그래밍 언어에 필수적으로 내장된 자료형으로는 정수형, 실수형, 문자형, 논리형이 있다.

형 시스템이란 자료형을 정의하고 변수를 특정된 자료형으로 선언하는 도구라 할 수 있다.

형 시스템은 신뢰성 증가뿐만 아니라 프로그램을 읽기 쉽게 해준다.

- 강자료형(strongly type): 자료형에 관한 특성이 번역시간에 확정되는 프로그래밍 언어
- 스칼라형(scalar type): 자료형 영역이 단순한 상수값으로만 구성되어 있는 자료형
- 구조형(structured type): 상수값이 아닌 자료의 집합

### 스칼라 타입

모든 언어는 내장된 자료형을 가지고 있다.
이들 자료형에는 수치자료형, 논리형, 문자형이 있으며 주로 단순형이다.

#### 수치형

수치형은 스칼라형으로 정수 또는 실수의 근사값을 표현한다.
내장된 수치형은 산술적인 것을 구현할 때 컴퓨터의 하드웨어에 의존한다.

이 방법은 고급 프로그래밍 언어로 기술된 정수와 실수의 연산이 그대로 컴퓨터에 내장된 코드로 변환되므로
연산속도가 매우 빠르지만 고급 언어로 작성된 프로그램을 다른 컴퓨터로 이동시키고자 할때 어려움을 초래한다.

`Q = X + Y / Z` (Q, X는 실수형, Y, Z는 정수형)

- 방법1: `Q = X + REAL(Y / Z)`
- 방법2: `Q = X + REAL(Y) / REAL(Z)`

#### 논리형

논리형 값의 영역은 참과 거짓으로 구성된다.

일반적으로 논리형 자료에 관한 연산으로 다섯가지가 정의되어 있다.

- s and t
- s or t
- not s
- s imp(implies) t
- s equiv(equivalence) t

논리형에서 쟁점은 상수의 표현이다

- `true` / `false`
- 수 값과 혼합연산 허용/불가
- 정의된 열거형 `[FALSE, TRUE]`
- 값이 0이 아닌 비트 (`true`) / 값이 0 (`false`)
- ...

#### 문자형

C언어에서는 문자형 `char`가 존재하지만 모든 정수형 변수가 문자를 표현하는데 사용될 수 있다.
C에서 문자열은 문자배열이다.

Java도 C언어의 개념을 가져와 원칙적으로는 같지만, 16비트의 유니코드를 원칙으로 하며 정수형과 형변환이 가능하다.

### 열거형 (enumeration type)

열거형의 영역은 리스트로 정해주며, 연산은 동등 및 순서 관계와 할당연산을 허용한다.

열거형을 정의하는 쉬운 방법으로 프로그래밍 언어는 새로운 자료형을 정의하고 선언할 수 있는 기법과
그 선언된 변수가 취할 수 있는 리터럴 값을 선언하는 기법을 제공해야 한다.

### 배열 (array)

프로그래밍 언어에서는 여러 자료를 묶어서 하나의 단위로 처리할 수 있는 구조형으로 배열(array)과 레코드(record)를 제공하고 있다.

배열은 이름, 차원, 원소형, 첨자집합의 형과 범위등으로 특정 짓는다.

배열의 특정 원소는 두 가지 수준의 구문기법에 의해 참조된다.
하나는 집합체의 이름이고, 다른 하나는 인덱스로 알려진 한 개 이상의 항목으로 구성된 선택자이다.

선택 연산은 배열이름과 인덱스값의 집합에서 집합체의 한 원소에 대응되는 사상(mapping)으로 간주된다.

전형적인 배열의 인덱스 집합은 연속적인 정수집합을 사용하지만 반드시 정수형으로 제한되지는 않는다.
인덱스 집합이 정수형인 경우 차원별로 하한(lb)과 상한(ub) 경계값을 언급하여 인덱스를 정의할 수 있다.

경계값은 `lb <= ub`를 만족시켜야 하며, 그 크기는 `ub - lb + 1` 이다.

배열 변수에 허용되는 인덱스의 바인딩은 보통 정적이지만, 인덱스값 영역이 때로는 동적 바인딩 된다.
정적 배열(static array)은 인덱스 범위가 정적으로 바인딩되고 기억장소 할당이 정적으로 이루어지는 배열이다.

컴퓨터의 기억장소는 일반적으로 1차원 구조이기 때문에 기억시키려는 배열을 연속적인 메모리에 기억시키는 것이 보통이다.
배열의 각 원소는 기억장소의 적당한 위치에 사상하며 이를 구현하기 위해 배열에 관한 정보를 갖는 명세표(descriptor)를 사용한다.

명세표는 배열이름과 원소의 형, 원소의 길이, 배열의 시작주소, 각 차원의 하한과 상한을 포함한다.
원소들은 일반적으로 행 우선(row major)순서로 저장된다. 언어에 따라 열우선(column major)으로 저장되기도 한다.

각 원소들의 위치는 `loc(M(i)) = 시작주소 - 차원하한 * size + i * size`로 구할 수 있으며 마지막항목 `i`만 실행시간에 변화하는 값이다.

### 연상배열 (associative array)

연상배열은 키(key) 값에 의해 접근되는 순서를 갖지 않는 데이터 원소의 집합체이다.
연상배열이 아닌경우 인덱스가 저장될 필요가 없으나, 연상배열에서는 사용자-정의 키가 배열에 함께 저장되어야 한다.

연상배열에 관한 설계 고려사항은 원소의 참조형 식과 연상배열 크기의 바인딩 시간이다.

일반적인 사용사례로 해시 테이블을 들 수 있다.
원소의 탐색이 요구될 때 배열보다 훨씬 효율적이다. 반면 리스트의 모든 원소를 처리할 경우에는 배열을 사용하는 것이 효율적이다.

### 레코드 (record)

레코드형은 이질적 자료로 구성된 조직적 자료형이다.

레코드형의 선언부는 어러 필드와 그들의 값에 대한 형을 기술한다.

```c
struct people =
{
  char name[30];
  double tall[200];
  double weight;
  int age[100];
}
people newpeople, num;
```

위의 선언은 다섯 개의 구성요소로 이루어진 people을 정의한다.
첫 번째 필드 name은 문자열의 배열, tall과 age 필드는 숫자형 배열, weight는 실수형이다.

변수 newpeople과 num은 people형을 갖는 변수로 선언되었다.

레코드와 각 필드를 참조하는 문제는 모든 언어가 동일한 방법을 제공하지는 않는다.

### 포인터 자료형

포인터(pointer)란 어떤 객체에 대한 기억장치 주소참조를 말한다.
포인터 변수(pointer variable)란 객체를 참조하는 기억장치 주소값으로 취하는 식별자이다.

모든 객체에 각각의 명시적인 이름을 제공하지 않고 많은 항목을 동적으로 연결하여 사용하기 위해 포인터 개념이 생겨났다.

객체가 동적으로 할당되는 기억장소 영역을 힙(heap)이라 한다.
힙에 할당되는 변수를 힙 변수라 하며 이러한 변수는 식별자 없이 포인터나 참조형 변수에 의해 참조될 수 있다.
이와같이 이름없는 변수를 무명변수(anonymous variable)라고 한다.

프로그래밍 언어는 자료항목 간에 다중관계(multiple relationship)를 선언할 필요성이 존재한다.
포인터는 하나의 자료가 많은 리스트에 동시에 연결되는 것을 혀용한다.

포인터는 형 연산자를 사용하여 정의하지만, 배열과 레코드와는 달리 구조형이 아니며 스칼라형도 아니다.
포인터는 자료를 저장하는 것이 아니라 다른 객체를 참조하는데 사용하기 때문이다.

포인터형을 제공하는 언어는 기본적인 포인터 연산(할당과 역참조) 두 가지를 제공한다.

#### 참조형

C++에서는 참조형이라 불리는 포인터형을 제공한다.
참조형 변수는 묵시적으로 항상 역참조되는 상수포인터이다.

Java에서 참조변수는 C++ 형태에서 포인터를 대체할 수 잇는 형태로 확장된다.
C++ 포인터와 Java 참조변수 간의 근본적인 차이는,
C++ 포인터는 메모리 주소를 참조하는 반면, Java 참조변수는 클래스 인스턴스를 참조한다는 것이다.

### 자료형 변환

자료형에 대한 정적 형 검사(static type checking)는 번역시간에 수행되며
동적 형 검사(dynamic type checking)는 실행시간에 수행된다.

수식을 기술할 때 프로그래머는 혼합형 연산(generic operation)의 사용을 원하지만
컴파일러는 형 고정 연산을 제공하므로 식에 사용된 자료형의 형 변환(type conversion)이 요구된다.

형 변환은 컴파일러에서 자동으로 수행하는 묵시적 형 변환과 프로그래머가 명시하는 명시적 형변환이 있다.

묵시적 형 변환은 강제로 컴파일러에 요구되어 자동으로 수행되는 자동 형변환 또는 강제변환(coercion)이라하고,
명시적 변환은 프로그래머가 명령문으로 요구한 형 변환으로 캐스트(cast)라 한다.

전형적으로 프로그래밍 언어에서는 스칼라형 사이의 형 변환은 제공되나 구조자료형이나 사용자정의형 사이에서는 형변환이 허용되지 않는다.
