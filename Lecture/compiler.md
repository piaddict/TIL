# 컴파일러

## 컴파일러 개요

- 원시 프로그램 -> 번역기 -> 목적 프로그램
- 어셈블리어 프로그램 -> 어셈블러 -> 기계어 프로그램
- 고급언어 프로그램 -> 컴파일러 -> 어셈블리어/기계어 프로그램
- 고급언어 프로그램 -> 프리프로세서 -> 고급언어 프로그램
- 고급언어 프로그램 -> 인터프리터 -> 실행결과

컴파일러는 목적코드에 따라 다음으로 분류할 수 있다

- native compiler
  - 일반적으로 사용되는 컴파일러
  - 컴파일러가 목적코드를 생산하고 나면 목적코드는 바로 컴퓨터에서 실행된다

- cross compiler
  - 임베디드 프로그램처럼 목적코드가 다른 컴퓨터나 운영체제에서 실행되도록 번역

- bytecode compiler
  - Java 언어가 대표적이다
  - 원시프로그램을 자바 바이트 코드 형태로 번역한다
  - 바이트코드는 자바 가상 머신에서 실행될 수 있는 코드이다

### 인터프리터

인터프리터의 처리과정을 보면, 고급언어로 작성된 원시 프로그램을 중간코드로 변환하고,
변환된 중간코드를 명령어 단위로 가져다가 디코드하고 실행을 한다.

그리고 명령어의 주소를 하나 늘린 후, 다음 명령어를 가져온다.

- 시작
- 다음 명령어 호출(fetch)
- 명령어 디코드(decode)
- 지정된 피연산자 호출
  - 원시연산 실행
    - 명령어 주소 하나 증가 `(다음)`
  - 실행중지 연산 `(종료)`
  - 지정된 연산으로 분기
    - 원시연산 실행
    - 명령어 주소 하나 증가 `(다음)`

### 컴파일러의 논리적 구조

- 원시 프로그램
- 어휘분석
- 구문분석
- 의미분석
- 중간코드 생성
- 코드최적화
- 목적코드생성
- 목적프로그램

#### 어휘분석 (lexical analysis)

어휘분석 단계에서는 원시 프로그램을 읽어 문장을 구성하고 있는 최소 단위인 어휘들을 떼어,
이 어휘들이 올바른지 분석하는 일을 한다.

따라서 모든 어휘를 정의한 문법(grammar)이 필요하다.
어휘분석 단계에서 문법에 의해 어휘가 분석되는데 올바르지 않으면 오류메시지가 출력되고,
올바른 경우 token 형태로 출력된다.

어휘 토큰은 의미 있는 최소의 문법적 단위(syntactic entity)가 되고,
이와 같은 일을 하는 것을 어휘분석기(lexical analyzer) 혹은 스캐너(scanner)라 한다.

토큰은 예약어(reserved word)나 상수(constant), 연산자(operator), 식별자(identifier),
괄호/따옴표/세미콜론등의 구분자(delimiter)등이 있다.

#### 구문분석 (syntax analysis)

구문분석 혹은 파싱(parsing)이라고 하며,
구문분석기(syntax analyzer) 혹은 파서(parser)가
어휘분석 결과인 토큰을 입력받아 이어지는 토큰들이 올바른 문장구조를 갖고 있는지 검사한다.

구문분석 단계에서도 문장구조를 정의할 문법이 필요하다.

문장을 정의한 문법에 맞는지 분석하는데,
올바른 문장에 대해서는 문장에 대한 구문구조(syntatic structure)를 만들어 출력하고
올바르지 않은 문장에 대해서는 오류메시지를 출력한다.

구문구조는 토큰들을 단말노드(terminal node)로 하는 tree 형태로 표현되는데,
이 트리를 parse tree라 한다.

parse tree는 중간코드 생성단계에서 이용된다.
parse tree에서 불필요한 정보인 식별자, 숫자, 식 등을 제거하고
다음 단계에서 필요한 정보만으로 구성된 트리를 구문트리(syntax tree)라고 한다.

#### 의미분석 (semantic analysis)

구문트리에 어떤 의미가 있고 어떤 기능을 수행하는지 분석하고,
수행환경을 조성하는 것을 의미분석기 (semantic analyzer)라 한다.

구문트리를 보며 산술식과 각 문장의 연산자 및 피연산자를 인식하고 type checking 등을 한다.

#### 중간코드 생성 (intermediate code generation)

중간코드 생성은 구문분석 단계에서 만들어진 구문트리를 이용하여 코드를 생성하거나,
구문지시적변환(syntax-directed translation)으로 이루어진다.

구문지시적 변환은 문법규칙이 reduce될 때 그 규칙에 맞는 코드생성 루틴을 부름으로써
중간코드 생성기(intermediate code generator)에 의해 중간코드를 생성한다.

`ABC := E * 3.14 + ABC / E`는 구문분석에서 얻어진 parse tree에 의해 다음과 같은 quadruple 중간코드를 얻는다

| 중간코드 | 의미 |
| --- | --- |
| `(*, E, 3.14, T0)` | `T0 = E * 3.14` |
| `(/, ABC, E, T1)` | `T1 = ABC / E` |
| `(+, T0, T1, T2)` | `T2 = T0 + T1` |
| `(:=, T2, Φ, ABC)` | `ABC := T2` |

#### 코드최적화 (code optimization)

코드를 효율적으로 만들어 코드 실행시 기억공간이나 실행시간을 절약하기 위한 단계이다.

최적화는 방법에 따라 여러가지로 나눌 수 있다

- Local(Peephole) optimization / Global optimization
- 단일문 최적화 / Loop 문장에서 최적화
- 실행속도 최적화 / 기억장소 최적화

지역최적화란 부분적인 관점에서 비효율적인 코드를 구분해내고, 이를 효율적으로 수정한다

- 중복된 LOAD, STORE 명령문 제거
- 불필요한 코드 제거
- 제어흐름 최적화
- 식(expression)의 대수학적 간소화(algebraic simplication)
- 연산의 세기경감(strenth reduction)
- 상수전파(constant propagation)
- 복사전파(copy propagation)
- 공통부분식(common subexpression) 제거
- 결합 변형
- ...

전역최적화는 전체적인 관점에서 보다 효율적인 코드로 수정한다

- 코드 이동(code motion)
- 귀납변수(induction variable) 최적화
- 루프융합(loop fusion)
- 루프전개(loop unrolling)
- ...

#### 목적코드 생성(code generation)

컴파일 과정의 마지막 단계로 연산을 수행할 레지스터를 선택하거나 자료에 기억장소의 위치를 정해주며,
실제로 목적기계어에 대한 코드를 생성하는 단계이다.

중간 코드 생성 단계에서 만들어진 중간코드들을 기계명령어(machine instruction)으로 바꾸어준다

### 컴파일러의 물리적 구조

컴파일러의 논리적 구조를 실제로 구현하는 경우 물리적 구조는 논리적 구조와 반드시 일치하지는 않는다.

컴파일러 구현에서는 여러단계를 모아서 하나의 모듈로 묶을 수 있는데, 이를 pass라 한다.
컴파일러의 구현방법으로는 크게 두 가지가 있다.

- one-pass compiler: 컴파일러의 전 과정을 하나의 패스로 구현
  - 초창기의 컴파일러
  - forward jump 처리를 위해 빈칸으로 남긴 부분을 backpatching으로 채움
  - 효율성이 좋고 실행속도가 빠르다

- two-pass compiler: 컴파일러의 구성을 중간코드를 기점으로 하여, 전/후반부로 구분함
  - 전반부: 어휘분석, 구문분석, 중간코드 생성
  - 후반부: 코드최적화, 목적코드 생성
  - 기계코드 표현에 제약을 받고 실행속도가 느리다
  - 이식성이 좋고 중간코드를 이용하여 최적화 하므로 기계와 독립적인 최적화 가능
  - 하나의 패스가 사용했던 공간을 재사용하므로 기억장소 절약 가능

### 간단한 컴파일러

`ABC := E * 3.14 + ABC / E`

문제를 간단히 하기 위해 조건을 한정하자

- 연산결과를 저장하는 누산기는 1개
- 연산자인 곱셈, 나눗셈이 덧셈, 뺄셈보다 연산순위가 높다
- 연산자인 덧셈, 뺄셈은 치환연산자 (:=)보다 연산순위가 높다

순서는 다음과 같다

- 컴파일러는 입력장치를 통해 원시 프로그램 string을 기억장치로 읽어 들인다
- 기억장치 내에 있는 문자의 열을 한 문자씩 왼쪽부터 scanning 한다
- 공백은 건너뛰고, 처음 토큰부터 어휘분석기로 종류를 판별한다
- 식별자를 판별하면 기호표에 기록한다 (변수, 상수 ...)
- 토큰에대한 식별번호를 기록한다
- 피연산자 || 연산자 스택에 기록한다
- 연산자 스택에 이미 자료가 있다면 연산자 우선순위를 비교한다

스택의 TOP 연산자가 우선순위가 높다면(연산처리)

- 연산자 스택의 TOP 요소와 피연산자 스택 요소 2개를 꺼내 연산한다
- 누산기의 계수기를 통해 다른 연산결과가 저장되어 있는지 확인한다
  - 다른 결과가 있다면 누산기를 사용하기 위해서 내용을 임시저장소에 저장해야 한다
  - 누산기 계수기를 따라가 임시기억장소인 작업용 번지의 주소로 교체한다
- 누산기의 식별번호를 피연산자 스택에 넣는다
- 누산기의 계수기에 피연산자 스택의 번지를 저장한다
- 누산자 계수기를 증가시킨다

현재 연산자가 우선순위가 높다면: 연산자 스택에 기록한다

위와 같은 과정을 반복한고, 문장이 끝났다는 구분자 `;`를 만나면 스택을 정리하기 시작한다

스택정리는 연산처리 부분을 반복하며 이루어진다

## 형식언어와 오토마타

### 형식언어의 기초

- 알파벳 < 문자열 < 형식언어

- 형식언어(formal language): 어떤 알파벳에서 얻은 symbol들로 구성되는 문자열들의 집합
- 알파벳: 기호들의 유한집합
- 문자열: 알파벳을 구성하는 기호가 0 또는 1개 이상 나열(sequence)된 것

- 문자열의 길이: 문자열을 이루는 기호들의 개수를 문자열 길이(cardinality)라 하고 `|w|`로 표시한다
- 공문자열: 문자열의 길이가 0인 것을 공문자열(empty string)이라고 한다

- `T*` (star closure): 공문자열을 포함하여, T에 속하는 기호들로 이루어질 수 있는 모든 문자열의 집합
- `T+` (positive closure): `T*`에서 공문자열을 제외한 모든 문자열의 집합을 나타낸다

앞의 정의들로 언어(language)를 정의하면

> 알파벳 T에 대한 언어 L은 `T*`의 부분집합이다

### 형식문법

형식문법이란 형식언어를 생성하기 위한 규칙들로 다음과 같이 정의할 수 있다

- 형식문법 `G = (Vn, Vt, P, S)`
  - `Vn`: 논터미널 기호들의 유한집합
  - `Vt`: 터미널 기호들의 유한집합
  - `P`: 생성규칙의 집합: `a -> b`, `a ∈ V+`, `b ∈ V*`
  - `S`: `Vn`에 속하는 기호로 다른 논터미널과 구별하여 시작기호라고 한다

기호들의 일반적인 표기법을 나타내면 다음과 같다.

- A, B, C 와 같은 영문자 대문자로 구성된 기호와 시작기호를 나타내는 S는 논터미널 기호이다
- `<`와 `>`로 묶어서 나타낸 기호도 논터미널 기호이다
- a, b, c와 같은 영문자 소문자로 구성된 기호와 +, -와 같은 연산자기호, 괄호나 쉼표와 같은 구분자, 0, 1, 2와 같은 아라비아 숫자들은 터미널 기호이다
- X, Y, Z와 같은 영문자 끝부분의 대문자는 터미널 기호와 논터미널 기호를 나타내는 문법기호이다
- 영문자 끝부분의 소문자인 u, v, w, x, y, z 등은 터미널 기호들로 이루어진 문자열을 나타낸다
- α, β, γ와 같은 그리스어 소문자는 문법기호로 구성된 문자열을 나타낸다
- 아무런 언급이 없으면 첫 번재 생성규칙의 왼쪽에 있는 기호가 시작기호이다

#### chomsky 계층구조

type0 > type1 > type2 > type3

- type 0: α → β: 위축형 문법 포함: 튜링기계

- type 1: α → β, |α| ≤ |β|: 비위축형 문법: linear-bounded 오토마타

- type 2 (Context Free Grammar) <- BNF: A → γ, A ∈ Vn: 푸시다운 오토마타

- type 3 (Regular Grammar): `non-terminal → [non-terminal]terminal`: 유한 오토마타
  - 우선형(우측-B 증가): A → tB, A → t
  - 좌선형(좌측-B 증가): A → Bt, A → t

### 정규표현

- Φ: 공집합
- ε
- a ∈ Vt: {a}
- 만일 P, Q가 정규언어 Lp, Lq를 표현하는 정규표현이라 하면
  - (P+Q): `a+b`
  - (P·Q): `ab`
  - (P*): `a*`, `(ab)*`, `(a+b)*`

### 정규언어와 유한 오토마타 (Finite Automata)

문자열(w) -> 유한 오토마타 (`w ∈ L(T)`) -> Yes | No

- 프로그램 설계를 위한 수학적 모델
- 그 시스템의 변화할 수 있는 상태가 유한개임을 말한다
- 문자열이 언어의 문장인지 판단한다
