# 컴파일러

## 컴파일러 개요

- 원시 프로그램 -> 번역기 -> 목적 프로그램
- 어셈블리어 프로그램 -> 어셈블러 -> 기계어 프로그램
- 고급언어 프로그램 -> 컴파일러 -> 어셈블리어/기계어 프로그램
- 고급언어 프로그램 -> 프리프로세서 -> 고급언어 프로그램
- 고급언어 프로그램 -> 인터프리터 -> 실행결과

컴파일러는 목적코드에 따라 다음으로 분류할 수 있다

- native compiler
  - 일반적으로 사용되는 컴파일러
  - 컴파일러가 목적코드를 생산하고 나면 목적코드는 바로 컴퓨터에서 실행된다

- cross compiler
  - 임베디드 프로그램처럼 목적코드가 다른 컴퓨터나 운영체제에서 실행되도록 번역

- bytecode compiler
  - Java 언어가 대표적이다
  - 원시프로그램을 자바 바이트 코드 형태로 번역한다
  - 바이트코드는 자바 가상 머신에서 실행될 수 있는 코드이다

### 인터프리터

인터프리터의 처리과정을 보면, 고급언어로 작성된 원시 프로그램을 중간코드로 변환하고,
변환된 중간코드를 명령어 단위로 가져다가 디코드하고 실행을 한다.

그리고 명령어의 주소를 하나 늘린 후, 다음 명령어를 가져온다.

- 시작
- 다음 명령어 호출(fetch)
- 명령어 디코드(decode)
- 지정된 피연산자 호출
  - 원시연산 실행
    - 명령어 주소 하나 증가 `(다음)`
  - 실행중지 연산 `(종료)`
  - 지정된 연산으로 분기
    - 원시연산 실행
    - 명령어 주소 하나 증가 `(다음)`

### 컴파일러의 논리적 구조

- 원시 프로그램
- 어휘분석
- 구문분석
- 의미분석
- 중간코드 생성
- 코드최적화
- 목적코드생성
- 목적프로그램

#### 어휘분석 (lexical analysis)

어휘분석 단계에서는 원시 프로그램을 읽어 문장을 구성하고 있는 최소 단위인 어휘들을 떼어,
이 어휘들이 올바른지 분석하는 일을 한다.

따라서 모든 어휘를 정의한 문법(grammar)이 필요하다.
어휘분석 단계에서 문법에 의해 어휘가 분석되는데 올바르지 않으면 오류메시지가 출력되고,
올바른 경우 token 형태로 출력된다.

어휘 토큰은 의미 있는 최소의 문법적 단위(syntactic entity)가 되고,
이와 같은 일을 하는 것을 어휘분석기(lexical analyzer) 혹은 스캐너(scanner)라 한다.

토큰은 예약어(reserved word)나 상수(constant), 연산자(operator), 식별자(identifier),
괄호/따옴표/세미콜론등의 구분자(delimiter)등이 있다.

#### 구문분석 (syntax analysis)

구문분석 혹은 파싱(parsing)이라고 하며,
구문분석기(syntax analyzer) 혹은 파서(parser)가
어휘분석 결과인 토큰을 입력받아 이어지는 토큰들이 올바른 문장구조를 갖고 있는지 검사한다.

구문분석 단계에서도 문장구조를 정의할 문법이 필요하다.

문장을 정의한 문법에 맞는지 분석하는데,
올바른 문장에 대해서는 문장에 대한 구문구조(syntatic structure)를 만들어 출력하고
올바르지 않은 문장에 대해서는 오류메시지를 출력한다.

구문구조는 토큰들을 단말노드(terminal node)로 하는 tree 형태로 표현되는데,
이 트리를 parse tree라 한다.

parse tree는 중간코드 생성단계에서 이용된다.
parse tree에서 불필요한 정보인 식별자, 숫자, 식 등을 제거하고
다음 단계에서 필요한 정보만으로 구성된 트리를 구문트리(syntax tree)라고 한다.

#### 의미분석 (semantic analysis)

구문트리에 어떤 의미가 있고 어떤 기능을 수행하는지 분석하고,
수행환경을 조성하는 것을 의미분석기 (semantic analyzer)라 한다.

구문트리를 보며 산술식과 각 문장의 연산자 및 피연산자를 인식하고 type checking 등을 한다.

#### 중간코드 생성 (intermediate code generation)

중간코드 생성은 구문분석 단계에서 만들어진 구문트리를 이용하여 코드를 생성하거나,
구문지시적변환(syntax-directed translation)으로 이루어진다.

구문지시적 변환은 문법규칙이 reduce될 때 그 규칙에 맞는 코드생성 루틴을 부름으로써
중간코드 생성기(intermediate code generator)에 의해 중간코드를 생성한다.

`ABC := E * 3.14 + ABC / E`는 구문분석에서 얻어진 parse tree에 의해 다음과 같은 quadruple 중간코드를 얻는다

| 중간코드 | 의미 |
| --- | --- |
| `(*, E, 3.14, T0)` | `T0 = E * 3.14` |
| `(/, ABC, E, T1)` | `T1 = ABC / E` |
| `(+, T0, T1, T2)` | `T2 = T0 + T1` |
| `(:=, T2, Φ, ABC)` | `ABC := T2` |

#### 코드최적화 (code optimization)

코드를 효율적으로 만들어 코드 실행시 기억공간이나 실행시간을 절약하기 위한 단계이다.

최적화는 방법에 따라 여러가지로 나눌 수 있다

- Local(Peephole) optimization / Global optimization
- 단일문 최적화 / Loop 문장에서 최적화
- 실행속도 최적화 / 기억장소 최적화

지역최적화란 부분적인 관점에서 비효율적인 코드를 구분해내고, 이를 효율적으로 수정한다

- 중복된 LOAD, STORE 명령문 제거
- 불필요한 코드 제거
- 제어흐름 최적화
- 식(expression)의 대수학적 간소화(algebraic simplication)
- 연산의 세기경감(strenth reduction)
- 상수전파(constant propagation)
- 복사전파(copy propagation)
- 공통부분식(common subexpression) 제거
- 결합 변형
- ...

전역최적화는 전체적인 관점에서 보다 효율적인 코드로 수정한다

- 코드 이동(code motion)
- 귀납변수(induction variable) 최적화
- 루프융합(loop fusion)
- 루프전개(loop unrolling)
- ...

#### 목적코드 생성(code generation)

컴파일 과정의 마지막 단계로 연산을 수행할 레지스터를 선택하거나 자료에 기억장소의 위치를 정해주며,
실제로 목적기계어에 대한 코드를 생성하는 단계이다.

중간 코드 생성 단계에서 만들어진 중간코드들을 기계명령어(machine instruction)으로 바꾸어준다

### 컴파일러의 물리적 구조

컴파일러의 논리적 구조를 실제로 구현하는 경우 물리적 구조는 논리적 구조와 반드시 일치하지는 않는다.

컴파일러 구현에서는 여러단계를 모아서 하나의 모듈로 묶을 수 있는데, 이를 pass라 한다.
컴파일러의 구현방법으로는 크게 두 가지가 있다.

- one-pass compiler: 컴파일러의 전 과정을 하나의 패스로 구현
  - 초창기의 컴파일러
  - forward jump 처리를 위해 빈칸으로 남긴 부분을 backpatching으로 채움
  - 효율성이 좋고 실행속도가 빠르다

- two-pass compiler: 컴파일러의 구성을 중간코드를 기점으로 하여, 전/후반부로 구분함
  - 전반부: 어휘분석, 구문분석, 중간코드 생성
  - 후반부: 코드최적화, 목적코드 생성
  - 기계코드 표현에 제약을 받고 실행속도가 느리다
  - 이식성이 좋고 중간코드를 이용하여 최적화 하므로 기계와 독립적인 최적화 가능
  - 하나의 패스가 사용했던 공간을 재사용하므로 기억장소 절약 가능

### 간단한 컴파일러

`ABC := E * 3.14 + ABC / E`

문제를 간단히 하기 위해 조건을 한정하자

- 연산결과를 저장하는 누산기는 1개
- 연산자인 곱셈, 나눗셈이 덧셈, 뺄셈보다 연산순위가 높다
- 연산자인 덧셈, 뺄셈은 치환연산자 (:=)보다 연산순위가 높다

순서는 다음과 같다

- 컴파일러는 입력장치를 통해 원시 프로그램 string을 기억장치로 읽어 들인다
- 기억장치 내에 있는 문자의 열을 한 문자씩 왼쪽부터 scanning 한다
- 공백은 건너뛰고, 처음 토큰부터 어휘분석기로 종류를 판별한다
- 식별자를 판별하면 기호표에 기록한다 (변수, 상수 ...)
- 토큰에대한 식별번호를 기록한다
- 피연산자 || 연산자 스택에 기록한다
- 연산자 스택에 이미 자료가 있다면 연산자 우선순위를 비교한다

스택의 TOP 연산자가 우선순위가 높다면(연산처리)

- 연산자 스택의 TOP 요소와 피연산자 스택 요소 2개를 꺼내 연산한다
- 누산기의 계수기를 통해 다른 연산결과가 저장되어 있는지 확인한다
  - 다른 결과가 있다면 누산기를 사용하기 위해서 내용을 임시저장소에 저장해야 한다
  - 누산기 계수기를 따라가 임시기억장소인 작업용 번지의 주소로 교체한다
- 누산기의 식별번호를 피연산자 스택에 넣는다
- 누산기의 계수기에 피연산자 스택의 번지를 저장한다
- 누산자 계수기를 증가시킨다

현재 연산자가 우선순위가 높다면: 연산자 스택에 기록한다

위와 같은 과정을 반복한고, 문장이 끝났다는 구분자 `;`를 만나면 스택을 정리하기 시작한다

스택정리는 연산처리 부분을 반복하며 이루어진다

## 형식언어와 오토마타

### 형식언어의 기초

- 알파벳 < 문자열 < 형식언어

- 형식언어(formal language): 어떤 알파벳에서 얻은 symbol들로 구성되는 문자열들의 집합
- 알파벳: 기호들의 유한집합
- 문자열: 알파벳을 구성하는 기호가 0 또는 1개 이상 나열(sequence)된 것

- 문자열의 길이: 문자열을 이루는 기호들의 개수를 문자열 길이(cardinality)라 하고 `|w|`로 표시한다
- 공문자열: 문자열의 길이가 0인 것을 공문자열(empty string)이라고 한다

- `T*` (star closure): 공문자열을 포함하여, T에 속하는 기호들로 이루어질 수 있는 모든 문자열의 집합
- `T+` (positive closure): `T*`에서 공문자열을 제외한 모든 문자열의 집합을 나타낸다

앞의 정의들로 언어(language)를 정의하면

> 알파벳 T에 대한 언어 L은 `T*`의 부분집합이다

### 형식문법

형식문법이란 형식언어를 생성하기 위한 규칙들로 다음과 같이 정의할 수 있다

- 형식문법 `G = (Vn, Vt, P, S)`
  - `Vn`: 논터미널 기호들의 유한집합
  - `Vt`: 터미널 기호들의 유한집합
  - `P`: 생성규칙의 집합: `a -> b`, `a ∈ V+`, `b ∈ V*`
  - `S`: `Vn`에 속하는 기호로 다른 논터미널과 구별하여 시작기호라고 한다

기호들의 일반적인 표기법을 나타내면 다음과 같다.

- A, B, C 와 같은 영문자 대문자로 구성된 기호와 시작기호를 나타내는 S는 논터미널 기호이다
- `<`와 `>`로 묶어서 나타낸 기호도 논터미널 기호이다
- a, b, c와 같은 영문자 소문자로 구성된 기호와 +, -와 같은 연산자기호, 괄호나 쉼표와 같은 구분자, 0, 1, 2와 같은 아라비아 숫자들은 터미널 기호이다
- X, Y, Z와 같은 영문자 끝부분의 대문자는 터미널 기호와 논터미널 기호를 나타내는 문법기호이다
- 영문자 끝부분의 소문자인 u, v, w, x, y, z 등은 터미널 기호들로 이루어진 문자열을 나타낸다
- α, β, γ와 같은 그리스어 소문자는 문법기호로 구성된 문자열을 나타낸다
- 아무런 언급이 없으면 첫 번재 생성규칙의 왼쪽에 있는 기호가 시작기호이다

#### chomsky 계층구조

type0 > type1 > type2 > type3

- type 0: α → β: 위축형 문법 포함: 튜링기계

- type 1: α → β, |α| ≤ |β|: 비위축형 문법: linear-bounded 오토마타

- type 2 (Context Free Grammar) <- BNF: A → γ, A ∈ Vn: 푸시다운 오토마타

- type 3 (Regular Grammar): `non-terminal → [non-terminal]terminal`: 유한 오토마타
  - 우선형(우측-B 증가): A → tB, A → t
  - 좌선형(좌측-B 증가): A → Bt, A → t

### 정규표현

- Φ: 공집합
- ε
- a ∈ Vt: {a}
- 만일 P, Q가 정규언어 Lp, Lq를 표현하는 정규표현이라 하면
  - (P+Q): `a+b`
  - (P·Q): `ab`
  - (P*): `a*`, `(ab)*`, `(a+b)*`

### 정규언어와 유한 오토마타 (Finite Automata)

#### 유한 오토마타

> 문자열(w) -> 유한 오토마타 (`w ∈ L(T)`) -> Yes | No

문자열 w를 입력받아서 w가 언어 L(T)의 문장이면 Yes를 답하고 그렇지 않으면 No를 답하는 프로그램이다

일반적으로 컴파일러 중에서 어휘분석기는 대표적인 유한 오토마타이다.

유한 오토마타를 표현하는 방법에는 다음 두 가지가 있다.

- 정의에 따라서 5가지의 구성원소를 형식에 맞게 정확히 표현하는 방법
  - Q: 상태들의 유한집합
  - Σ: 입력기호들의 유한집합
  - q0: 시작상태 또는 출발상태 (q0 ∈ Q)
  - F: 종료상태들의 집합 (F ∈ Q)
  - δ: 상태전이함수 (Q X Σ -> 2^Q(Q의 멱집합))

- 상태전이도(transition diagram)라는 그림을 이용하여 비형식적으로 표현하는 방법
  - 오토마타의 각 상태를 노드로 나타내는 그림
  - 상태전이도에서는 상태 q에서 p로 가는 지시선 위에 a를 표기한다
  - 종결상태는 이중 원으로 나타내고, 시작상태는 시작 지시선으로 표시하는 directed graph이다

#### DFA(결정적 유한 오토마타) / NFA(비결정적 유한 오토마타)

- DFA: 하나의 입력문자열에 대하여 오직 하나의 다음 상태가 결정되는 것
- NFA: 어떤 상태에서 주어진 하나의 입력기호를 보고, 갈 수 있는 다음 상태가 하나 이상 존재할 수 있는 유한 오토마타이다

#### DFA와 NFA의 동치관계

NFA는 언어의 구조를 쉽게 표현할 수 있는 반면, DFA보다 프로그램으로 구현하기 어렵다.
따라서 일반적인 구현은 DFA로 하게되고 NFA에서 변환하게 된다.

- ε-전이가 있는 NFA를 DFA로 변환
  - ε-closure(S): S가 한 개일 경우 S와 S로 부터 레이블이 ε인 지시선으로 도달할 수 있는 모든 상태의 집합
  - T가 하나 이상의 상태집합으로 되어 있는 경우에 ε-closure(T)는 T속에 있는 각 상태에 대해 위와 같은 방법으로 집합군은 구하여 합한것
  - 변환
    - ε-NFA의 시작상태 q0에 대해 ε-closure(q0)를 구하고 ε-closure(q0)를 DFA의 시작상태로 놓는다
    - ε-closure(q0)의 원소들에 대해서 ε-NFA에 있는 ε을 제외한 각각의 입력기호에 대해 갈 수 있는 상태집합을 T1, T2 ...
    - ε-closure(T1), ε-closure(T2) ... 를 구하여 DFA의 새로운 상태로 만들고, 이전에 만들어진 상태면 지시선만 만든다
    - 과정을 되풀이하여 새로운 상태가 나타나지 않을 때 까지 계속한다
    - 만들어진 상태중에서 ε-NFA의 종료상태를 포함하는 상태는 모두 DFA의 종료상태가 된다

- ε-전이가 없는 NFA를 DFA로 변환
  - NFA에 의해서 인식되는 언어를 L이라 하면, L을 인식하는 DFA가 존재한다
  - L을 인식하는 NFA M = (Q, Σ, δ, q0, F)라 놓으면
  - DFA M' = (Q', Σ', δ', q0', F')는 다음과 같이 구성된다
    - Q' = 2^Q
    - F = {M의 종료상태를 포함하는 Q'안에 있는 모든 상태의 집합}
    - q0' = [q0]

#### DFA의 상태수 최소화

상태수를 최소화하는 방법은 동치관계를 이용하여 상태수를 합침(state merge)으로써 상태수를 최소화할 수 있다.

- w ∈ Σ* 에 대해서 q1에서 w를 다 본 상태가 q3이고 q2에서 w를 다 본 상태가 q4일 때, q3, q4 중 하나만 종료상태에 속하면 q1은 q2로부터 구별(distinguish)된다고 말한다
- 만약 상태집합 Q속에 상태가 도달 가능하지 않고, Q의 서로 다른 두 상태가 구별 가능하지 않다면 축약(reduce)될 수 있다

상태수 최소화는 다음과 같은 과정으로 이루어진다

1. 시작상태로부터 도달 불가능한 상태를 모두 제거한다
2. 초기의 동치관계인 [종료상태]와 [미결상태]의 두 동치류로 분할한다
3. 같은 입력기호에 대해 서로 다른 동치류로 가는 지시선이 존재하면 또 다른 분할을 하여 새로운 동치류를 만든다
4. 3의 과정을 되풀이하여 더 이상 새로운 분할이 일어나지 않을 때까지 반복한다
5. M의 종료상태에 속하는 상태가 동치류 속에 들어 있으면 이 동치류는 M'의 종료상태이다

#### 정규문법, 정규표현, 유한 오토마타의 동치관계

정규문법, 정규표현, 유한 오토마타는 서로 변환되는 동치관계이다

정규표현을 유한 오토마타로 변환하는 과정은 다음과 같다

- 정규표현으로부터 NFA를 구한다
- NFA를 DFA로 변환한 다음 최호화된 DFA를 구한다

유한 오토마타를 정규문법으로 변환하는 과정은 다음과 같다

- 상태전이도에서 각각의 상태를 하나의 논터미널이라 하고 입력기호를 터미널 기호라 하자
- 정규문법을 작성하는데 왼편에는 상태를 나타내는 논터미널을 쓴다
- 오른편에는 전이지시선 위에 있는 입력기호인 터미널 기호를 쓰고 다음에 전이되는 상태를 쓴다
