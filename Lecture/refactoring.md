# Refactoring

## 리팩토링 개론

### 리팩토링은 무엇인가

리팩토링: 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업

리팩토링의 목적은 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것이다.
리팩토링은 성능 최적화와 상반된다. 성능 최적화를 수행하면 코드를 파악하기 더 어려워질 때가 많다.

소프트웨어 개발에 리팩토링을 적용할 때 기능 추가와 리팩토링이라는 별개의 두 작업에 시간을 분배해야 한다.

- 기능을 추가할 땐 코드를 수정하지 말고 기능만 추가해야 하며, 진행상태를 파악하려면 테스트를 추가하고 통과여부를 확인한다
- 리팩토링 할 때는 코드를 추가하지 말고 코드 구조 개선만 해야 한다
- 인터페이스가 변경되어 그에 맞게 코드를 고치는 것이 불가할 때는 테스트만 변경해야 한다

### 리팩토링 목적

- 소프트웨어 설계 개선
  - 지속적으로 코드를 수정하면 코드 구조가 복잡해진다
  - 코드의 처음 설계구조를 유지하려면 정기적으로 리팩토링을 실시해야 한다
  - 특히 설계가 깔끔하지 않으면 중복코드로 인해 쓸데없이 코드가 길어진다

- 소프트웨어 이해를 쉽게 한다
  - 코드에는 나중에 수정될 다른 개발자에 대한 고려가 반영되어야 한다
  - 코드를 파악하기 쉽게 수정하기 위한 과정이 리팩토링이다
  - 리팩토링을 하면서 낮선 코드를 쉽게 이해할 수도 있다

- 버그를 찾기 쉬워진다
  - 프로그램 구조를 명료하게 만들어 특정해놓은 전제들이 확실해지면 버그 발견하기가 쉬워진다

- 프로그래밍 속도가 빨라진다
  - 깔끔한 설계는 소프트웨어 개발속도를 높이기위한 핵심이다
  - 깔끔하지 않다면 버그를 찾고 중복코드를 찾느라 시간이 길어진다

### 리팩토링이 필요할 때

- 같은 작업의 삼진 아웃
  - 어떤 작업을 처음 하면 그냥 한다.
  - 비슷한 작업을 두 번째 하면 중복이라도 그냥 한다
  - 그러나 비슷한 작업을 세 번째 하게 되면 리팩토링을 실시해야 한다

- 기능을 추가할 때
  - 기능을 추가할 때 기존 코드를 이해하기 위해서, 혹은 이해하기 쉽게 만들기 위해 리팩토링이 필요하다
  - 리팩토링 여부는 이해가 쉽게 고칠 수 있는지 고민한 뒤 결정한다
  - 기능 추가 중 설계 때문에 작업의 어려움을 느낀다면 리팩토링을 실시해야 한다

- 버그 수정시
  - 버그를 수정하려면 코드의 기능을 파악하여야 하고 이를 위해 리팩토링을 실시한다
  - 버그 리포팅을 받았을 때도 리팩토링이 필요하다. 버그 존재를 파악하기 힘든 구조가 존재했기 때문이다

- 코드 검수시
  - 코드를 검수한다면 리팩토링을 통해 자신의 코드를 이해하기 쉽게 만들고 타인의 코드를 쉽게 이해하여야 한다

### 인다이렉션과 리팩토링

소프트웨어 공학자들은 인다이렉션을 광적으로 좋아한다는 점에서 대부분의 리팩토링에서 인다이렉션이 적용되는 것은 당연한 일이다.

그러나 인다이렉션은 양날의 검이다. 한 부분을 둘로 쪼개면 관리할 부분이 늘어난다.
또한 객체가 또 다른 객체에 작업을 위임하기 때문에 코드를 알아보기 힘들어질 수도 있다.

하지만 인다이렉션은 다음과 같은 장점이 있다

- 로직을 공유: 하나의 로직을 여러곳에서 공유할 수 있다
- 의도와 구현부를 분리: 클래스명과 메소드명으로 의도를 드러낼 수 있고, 클래스나 메소드의 내부 코드를 통해 의도를 어떻게 구현했는지 보여줄 수 있다
- 수정 부분을 분리: 한 객체를 두 위치에서 사용했는데 객체를 수정하면 두곳 다 변경될 위험이 있다. 이 때 하위클래스로 수정할 수 있다
- 조건문을 코드화: 조건문을 메시지로 바꾸면 중복코드가 줄어들어 명료해지며 유연성도 높아진다

### 리팩토링 관련 문제

#### 데이터베이스

수많은 비즈니스 애플리케이션은 데이터베이스 스키마와 강력히 결합되어 있다.
데이터베이스 스키마와 객체 모델의 상호 의존성을 최소화 하여 구성해도,
데이터베이스 스키마를 수정하면 데이터도 이전해야 하는데 시간도 오래 걸리며 위험성도 높다.

#### 인터페이스 변경

객체의 장점중 하나는 인터페이스를 건드리지 않고 내부 구현을 수정할 수 이:ㅆ다는 점이다.

하지만 인터페이스를 수정하면 어떤 문제가 발생할지 알 수 없다.
리팩토링에서 불안한 점은 상당수의 리팩토링이 인터페이스를 건드린다는 것이다.

만일 메소드를 사용하는 모든 코드에 접근할 수 있다면 메소드명을 변경하는 것은 문제가 되지 않을 수 이:ㅆ다.
public 메소드라 해도 메소드를 호출하는 부분을 수정할 수 있다면 변경가능하다.

그러나 인터페이스가 public 보다 더 적극적으로 공개된 published 인터페이스라면 문제가 생긴다.

published 인터페이스(공개한 라이브러리 인터페이스의 경우) 라면 해당 인터페이스를 사용하는 부분이 수정되기 전까지는
기존 인터페이스와 새 인터페이스를 모두 그대로 유지해야 한다.

이 경우 기존 인터페이스가 새 인터페이스를 호출하게 하면 된다. 더불어 deprecation을 통해 더 이상 사용하지 않는 인터페이스임을 알려야한다.

#### 리팩토링 하면 안 되는 상황

기존 코드를 리팩토링 할 수 있지만, 너무나 지저분해서 차라리 새로 작성하는 것이 나은 경우가 있다.

만일 코드가 돌아가지 않는다면 완전히 새로 작성해야 한다는 신호이다.
테스트만 하려다 코드가 안정화 될 수 없는 경우도 그런 경우이다.

종료 시점이 임박했을 때도 리팩토링은 피해야 한다.

### 리팩토링과 설계

리팩토링은 설계를 보완하는 특수한 역할을 한다.
설계가 핵심이고 프로그래밍은 구현 도구에 불과하다고 생각할 수 있으나, 설계에는 빈틈이 많다.

사전 설계 없이 리팩토링만 하는 방법을 택할수도 있지만, 결국 설계를 수정해야 하는 시점이 오면 큰 비용이 발생할 수도 있다.

리팩토링을 실시하더라도 여전히 설계는 해야 하지만, 사전 설계 과정에서 완벽함을 추구할 필요 없이 적당한 솔루션만 생각하면 된다.
솔루션을 구축해 나가면서 문제를 더 잘 이해하게 되며, 최상의 솔루션이 처음의 생각과는 다르다는 사실을 깨닫게 된다.

작업 중심 방식으로 이동하여 얻는 장점은 설계가 단순해진다는 점이다.

사전설계를 한다면 항상 발생하지도 않을 수정에 대한 비용을 걱정하느라 과도하게 유연한 솔루션을 갖추려하게 되고 이는 복잡성을 유발한다.

### 리팩토링과 성능

소프트웨어를 이해하기 쉽게 만드려면 수정할 일이 많은데, 그러한 수정으로 프로그램이 느려질수도 있다.

빠른 소프트웨어를 작성할 수 있는 일반적인 세 가지 방법이 있다

- 실시간 시스템에 주로 사용되는 시간분배
  - 설계를 분해하면서 각 구성요소에 시간이나 메모리 같은 자원별 예산을 할당하는 것
  - 컴포넌트간 할당된 시간의 상호교환은 혀용하나 예산을 초과하면 안된다
  - 이 방식은 철저히 성능 시간을 중시한다

- 성능에 관심을 가지는 것이다
  - 개발자에게 성능을 유지해야 함을 인식시키는 방법이다
  - 실제로 효과는 없는 편이다, 성능은 크게 오르지 않고 개발속도는 느려진다

- 성능에 관심을 가지는 방식의 문제점 개선
  - 개발 절차중 후기 단계에 있는 성능 최적화 전까지는 성능에 신경쓰지 않고 잘 쪼개진 방식의 프로그램을 제작하는 것
  - 성능 최적화 단계에서는 그 프로그램을 튜닝하는 절차를 따른다

## Code Smell
