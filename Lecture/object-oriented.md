# 객체지향 프로그래밍

"객체지향의 사실과 오해"를 읽으면서 요약한 것임

## 협력하는 객체

객체지향에서 가장 중요한 개념 세 가지는 역할, 책임, 협력이다.

애플리케이션의 기능은 더 작은 책임으로 분할되고 책임은 적절한 역할을 수행할 수 있는 객체에 의해 수행된다.
객체는 자신의 책임을 수행하는 도중에 다른 객체에 요청을 하기도 한다.

객체는 충분히 협력적이어야 한다. 다른 객체의 요청에 응답해야 하고, 응답여부를 객체 스스로 판단해야 한다.
또한 객체는 충분히 자율적이어야 한다. 즉 자신의 행동을 스스로 결정하고 책임질 수 있어야 한다.

### 협력과 메시지

객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른 객체로부터 메시지를 수신한다.
이때 메시지를 전송하는 객체를 송신자(sender)라 하고 메시지를 수신하는 객체를 수신자(receiver)라 한다.

수신자는 메소드(method)를 통해 수신된 메시지를 처리한다.
객체지향 프로그래밍에서 메소드는 클래스 안의 함수 또는 프로시저를 통해 구현된다.

메시지와 메소드의 분리는 객체의 협력에 참여하는 객체들간의 자율성을 증진시킨다.
메시지를 전송한 객체에서는 특정한 행동을 기대하지만 구체적인 방법에 관해서는 관여하지 않는다.

### 자율적인 객체

객체는 상태(state)와 행동(behavior)를 함께 지닌 실체이다.

객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 출발한다.
객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭할 수 없도록 차단해야 하고,
객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 소통해야 한다.

객체는 다른 객체가 무엇을 수행하는지 알 수 있지만, 어떻게 수행하는지에 대해서는 알 수 없다.

## 객체지향의 객체

객체는 상태(state), 행동(behavior), 식별자(identity)를 지닌 실체이다.

### 상태

객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다.
즉, 어떤 행동의 결과는 과거에 어떤 행동들이 일어났느냐에 의존한다.

그러나 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 설명할 수 있다.

그 자체로 독립적인 의미를 가지기보다는 다른 객체의 특성을 표현하는데 사용되는 것이 상태이다.
때로는 단순한 값이 아니라 객체를 사용해서 다른 객체의 상태를 표현해야 할 경우도 있다.
그런 경우 객체와 다른 객체가 연결되어 있는지 여부로 표현할 수 있다.

이처럼 객체와 객체 사이의 의미있는 연결을 링크(link)라 한다. 객체의 링크를 통해서만 메시지를 주고 받을 수 있다.
링크는 다른 객체를 참조할 수 있다는 것을 의미하며, 이는 한 객체가 다른 객체의 식별자를 알고 있는 것이다.

**결론적으로 모든 객체의 상태는 단순한 값과 객체의 조합으로 표현할 수 있다.**
이때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 한다.

일반적으로 property는 변경되지 않고 고정된다, 반면 property value는 시간이 흐름에 따라 변경되므로 동적이다.

### 행동

객체의 상태는 저절로 변하지 않는다. 객체의 상태를 바꾸는 것은 객체의 자발적인 행동 뿐이다.

객체의 행동에 의해 객체의 상태가 변경되는 것은 행동이 부수효과(side effect)를 초래한다는 것을 의미한다.
부수효과를 통해 객체의 행동을 상태 변경의 관점으로 기술할 수 있다.

객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다.
따라서, 상태와 행동 사이에는 다음과 같은 관계가 있다.

- 객체의 행동은 상태에 영향을 받는다: 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
- 객체의 행동은 상태를 변경시킨다: 상호작용이 어떻게 현재의 상태를 변경시키는가

또한 객체의 행동은 객체가 협력에 참여할 수 있는 방법이다.
객체가 어떤 행동을 하도록 만드는 것은 객체가 외부로부터 수신한 메시지다.

객체는 협력하는 과정에서 자기 자신의 상태뿐만 아니라 다른 객체의 상태변경을 유발할 수도 있다.
따라서 객체의 행동으로 인해 발생하는 결과는 두 가지로 볼 수 있다.

- **객체 자신의 상태 변경**
- **행동 내에서 협력하는 다른 객체에 대한 메시지 전송**

### 식별자

객체란 식별 가능한 경계를 가진 모든 사물이다.
객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다.

이 프로퍼티를 식별자라고 한다. 모든 객체는 식별자를 가지며 식별자를 이용해 객체를 구별할 수 있다.

반면 단순한 값은 식별자를 가지지 않는다.
값(value)은 숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링한다.

흔히 값의 상태는 변하지 않기 때문에 불변상태(immutable state)를 가진다고 한다.
따라서 값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스가 같은 것으로 판단할 수 있다.

이처럼 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성(equality)이라고 한다.

객체는 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다.
따라서 객체는 가변 상태(mutable state)를 가진다고 할 수 있다.

타입이 같은 두 객체의 상태가 완전히 똑같더라도 두 객체는 독립적인 별개의 객체로 다뤄야 한다.
객체의 경우 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성(identical)이라 한다.

- **객체는 어떤 상태에 있더라도 유일하게 식별가능하다**

### 캡슐화

현실과 객체지향 세계의 차이는, 객체지향에서 모든객체는 자신의 상태를 스스로 관리하는 자율적인 존재란 것이다.

현실에서는 층위가 존재하는 두 객체라도,
객체지향에서는 행동으로 상태변화를 일으키기 위해서 다른 객체에게 메시지를 전송하는 것이 전부이고 수신자의 상태 변경은 알지못한다.

이것이 캡슐화이다.
객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 방법 역시 행동 뿐이다.

상태를 외부에 노출 시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.

### 행동이 상태를 결정한다

상태를 중심으로 객체를 바라보면 안된다. 상태를 먼저 결정하고 행동을 나중에 결정하는 것은 설계에 나쁜영향을 준다.

- 상태를 먼저결정하면 캡슐화가 저해된다
- 객체를 협력이라는 문맥에서 벗어나게 만든다
- 객체의 재사용성이 저하된다

행동은 객체가 협력에 참여하는 유일한 방법이므로, 상태가 아닌 행동에 초점을 맞춰 객체를 설계해야 한다.

## 타입과 추상화

복잡한 구조 및 세부사항을 이해하기 쉽고 예측 가능한 수준으로 분해하고 단순화 하는 전략이 추상화이다.

- 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만든다
- 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만든다

### 객체지향과 추상화

객체지향의 수많은 객체들을 개별적인 단위로 취급하기에는 너무 방대하다.
따라서 공통적인 특성을 기준으로 개념(concept)을 적용하여 객체를 여러 그룹으로 묶는다.

개념을 이용하여 객체를 여러 그룹으로 분류(classification) 할 수 있다.

결국 각 객체는 특정한 개념을 표현하는 그룹의 일원이다.
개념 그룹의 일원이 된 객체를 그 개념의 인스턴스(instance)라 한다.

- 심볼(symbol): 개념을 가리키는 이름이나 명칭
- 내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지를 확인할 수 있음
- 외연(extension): 개념에 속하는 모든 객체의 집합

### 객체의 분류

분류란 특정한 객체를 특정한 개념의 객체 집합에 포함시키는 작업을 의미한다.

개념을 통해 객체를 분류하는 과정은 추상화의 두 가지 전략을 모두 사용한다.
개념으로 묶은 것은 개별 객체간의 세세한 특성을 배제하고 공통점을 취한 일반화 과정을 적용한 것이다.

### 타입

앞에서 설명한 개념을 컴퓨터공학적 용어로 표현하면 타입(type)이다.

데이터 타입은 메모리안에 저장된 데이터의 종류를 분류하는 데 사용되는 메모리 집합에 관한 메타데이터이다.
데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

객체를 타입에 따라 분류하고 타입에 이름을 붙이는 것은 새로운 데이터 타입을 선언하는 것이다.
그러나 객체는 데이터가 아니다. 객체에서 중요한 것은 객체의 행동이다.

**어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.**
어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.

**객체의 내부적인 표현은 외부로부터 철저히 감춰져야 한다.**
객체의 행동을 가장 효과적으로 수행할 수 있다면 객체 내부상태를 어떻게 표현하더라도 상관없다.

#### 행동 우선

객체가 다른 객체와 동일한 타입이라면 동일한 행동을 하기만 하면 된다.
객체가 어떤 데이터를 가지고 있는지는 타입 결정과는 아무런 관계가 없다.

여기에서 동일한 행동이란 동일한 책임을 의미하고, 동일한 책임이란 동일한 메시지 수신을 말한다.

다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를수 밖에 없다.
이를 통해 동일한 요청에 대해 다른 방식으로 응답하는 다형성을 갖게된다.

**즉, 다형적인 객체들은 동일한 타입 또는 타입계층에 속하게된다.**

**데이터의 내부 표현방식과 무관하게 행동만이 고려대상이라는 사실은 외부에 데이터를 감춰야 함을 의미하는데 이 원칙을 캡슐화라 한다.**

#### 타입의 계층

타입과 타입 사이에는 일반화/특수화 관계가 존재할 수 있다.

- 일반적 타입: 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입
- 특수한 타입: 일반적인 타입이 가진 모든 타입을 포함하지만 거기에 자신만의 행동을 추가한 타입

일반적인 타입을 슈퍼타입(supertype)이라 하고, 특수한 타입을(subtype)이라 한다.

어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행위적 호환성을 만족해야 한다.
일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야 한다.

### 정적 모델

타입을 사용하는 이유는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 위함이다.

객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다.
따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.

클래스는 타입을 구현할 수 있는 여러 방법중 하나이므로 클래스만으로 타입을 구현할 수 있는 것은 아니다.

## 역할 책임 협력

### 협력

이상한나라의 앨리스 예시를 살펴보자

- 누군가가 왕에게 재판을 요청하여 재판시작
- 왕이 하얀 토끼에게 증인을 부를 것을 요청
- 왕의 요청을 받은 토끼는 모자장수에게 증인석으로 입장할 것을 요청
- 모자장수는 증인석에 입장함으로써 토끼의 요청에 응답
- 모자장수의 입장은 왕이 토끼에게 요청했던 증인 호출에 대한 응답이기도 함
- 왕은 모자장수에게 증언할 것을 요청
- 모자장수는 자신이 알고 있는 내용을 증언함으로써 왕의 요청에 응답

어떤 객체가 특정한 요청을 받아들일 수 있는 이유는 요청에 대해 적절한 방식으로 응답하는데 필요한 행동방식을 갖고 있기 때문이다.

요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

### 책임

어떤 객체가 어떤 요청에 대해 답하거나 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 할 수 있다.

즉, 객체의 책임은 객체가 무엇을 알고 있는가(knowing)와 무엇을 할 수 있는가(doing)로 구성된다.

- 아는 것
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 대해 아는것

- 하는 것
  - 객체를 생성하거나 계산하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작하는 것
  - 다른 객체의 활동을 제어하고 조절하는 것

책임은 객체의 공용 인터페이스(public interface)를 구성한다.

#### 메시지

객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(message-send)이라 한다.

주의할 점은 책임과 메시지의 수준이 같지 않다는 점이다.

책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다.
책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할 되는 것이 일반적이다.

#### 역할

어떤 객체가 수행하는 책임의 집합은 객체가 협력안에서 수행하는 역할을 나타낸다.
앞의 예시에서 왕은 재판한다는 책임으로 판사, 모자장수는 증인석에 입장한다와 증언한다의 책임으로 증인의 역할을 수행하게 된다.

앞의 예시에 이어 모자장수 다음으로 요리사와 앨리스가 증언을하게된 상황을 살펴보자.
그러면 증언을 하게되는 협력과정이 세 번 반복된다.

세 번의 협력과정은 판사와 증인이라는 역할을 사용하여 하나의 협력으로 추상화 할 수 있다.

- 누군가가 **판사**에게 재판을 요청하여 재판시작
- **판사**가 하얀 토끼에게 증인을 부를 것을 요청
- **판사**의 요청을 받은 토끼는 **증인**에게 증인석으로 입장할 것을 요청
- **증인**은 증인석에 입장함으로써 토끼의 요청에 응답
- **증인**의 입장은 **판사**가 토끼에게 요청했던 증인 호출에 대한 응답이기도 함
- **판사**는 **증인**에게 증언할 것을 요청
- **증인**은 자신이 알고 있는 내용을 증언함으로써 **판사**의 요청에 응답

판사와 증인의 역할을 수행할 수 있는 객체는 역할에 해당하는 책임을 수행할 수 있는 객체이다.

그러나 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다.
왕은 재판을 할 책임 뿐만아니라 국정수행의 책임이있고, 모자장수는 증언을 하는 책임 이외에 모자를 판매할 책임이 있다.

### 객체와 협력

객체의 행위에 초점을 맞추기 위해서는 협력이라는 실행 문맥 안에서 책임을 분배해야 한다.
각 객체가 가져야 하는 상태와 행위에 대해 고민하기 전에 그 객체가 참여할 문맥인 협력을 정의해야 한다.

객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 만드는 것이다.

### 객체지향 설계 기법

- 책임 주도 설계
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다
  - 시스템 책임을 더 작은 책임으로 분할한다
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다
  - 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다

- 디자인 패턴
  - 디자인 패턴은 모범이 되는 설계이다
  - 디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍이다
  - 디자인 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다

- 테스트 주도 개발
  - 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다
  - 테스트에 필요한 간접 입력 값을 제공하기 위한 stub이나 간접 출력 값을 검증하기 위한 mock을 사용하는 것은 협력에 대한 것을 코드로 표현한 것이다

## 책임과 메시지
