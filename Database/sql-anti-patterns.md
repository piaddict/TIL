# SQL Anti Patterns

## 무단횡단

다대다 관계를 위한 교차테이블 생성을 피하기 위해 쉼표로 구분된 목록을 사용하는 경우

### 안티패턴: 쉼표로 구분된 목록에 저장

- 해당 데이터에서 일치하는 데이터를 검색하는 경우
- 해당 데이터를 FK로 사용해서 연관 데이터를 조회하는 경우 조인 자체도 어려울 뿐더러 조인시 인덱스를 활용할 기회가 사라진다
- 집계쿼리는 행의 그룹에 대해 사용하도록 되어 있으므로 사용이 어렵다
- 데이터 목록 정렬이 어렵다
- 연관 데이터의 갱신이 어렵다
- 입력 데이터의 유효성 검증이 어렵다
- 구분자 문자로 어떤것을 선택해야 할지에 대한 문제(comma를 사용한다면 본문의 comma는 어떻게 처리할 것인가?)
- 데이터 타입에 따라 목록 저장 길이 제한이 존재한다

### 쉼표로 구분된 목록 저장 사용이 합당한 경우

- 특정 쿼리는 역정규화를 적용해 성능을 높일 수 있다
- 이 경우 목록안의 개별항목에 접근할 필요가 없어야 한다
- 역정규화 적용은 보수적으로 접근해야 한다

### 해법: 교차 테이블 생성

- 어떤 테이블이 FK로 두 테이블을 참조할 때 이를 교차 테이블이라 한다
- 별도의 테이블에 각각의 행으로 저장하고 두 테이블 사이 다대다 관계를 생성한다
- 목록에 항목 추가/삭제는 교차 테이블에 행 삽입 삭제로 할 수 있다

## 순진한 트리

데이터가 재귀적 관계를 가지는 것은 흔한일이다. 데이터는 트리나 계층적 구조가 될 수 있다.
이러한 데이터를 조회할 때는 개별항목을 조회, 관련 부분만 조회, 전체를 조회하는 경우가 존재한다.

무한 계층 댓글, 조직도 등이 해당 자료구조라 할 수 있다.

### 안티패턴: 항상 부모에 의존

- 계층 데이터를 저장할 때 부모 데이터 id를 갖고 있는 방식의 설계를 인접 목록 (adjacency list)라 한다
- 인접목록에서 모든 자식 조회하기를 제대로 수행하지 못한다면 안티패턴이 된다
  - JOIN은 횟수가 정해져 있으므로 모든 계층을 가져온다면 많은 수행이 필요하고, 계층 제한이 없다면 실행조차 어렵다
  - 전체 데이터를 가져와 애플리케이션에서 계층을 생성하는 것은 느리고 매우 비효율적이다
- 인접 목록에서 노드 추가나 이동은 간단한 편이다. 그러나 삭제는 상당히 복잡하다.

### 항상 부모에 의존 사용이 합당한 경우

주어진 노드의 부모나 자식을 바로 얻거나 새로운 노드 추가만 주로 이루어지는 경우 인접목록 사용이 적합할 수도 있다.

어떤 DBMS는 인접 목록 형식으로 젖아된 계층 구조를 지원하기 위한 SQL 확장기능을 지원한다.
SQL-99 표준에는 WITH 키워드에 Common Table Expression을 사용한 재퀴적 쿼리문법이 있다.

### 해법: 대안 트리 모델 사용

계층 데이터 저장시 인접 목록의 대안으로 경로 열거, 중첩집합, 클로저 테이블 등이 있다.

#### 경로 열거(Path Enumeration)

인접목록의 약점중 하나는 트리에서 노드의 조상을 얻는데 비용이 크다는 것이다.
경로 열거 방법에서는 일련의 조상을 각 노드의 속성으로 저장해서 해결한다. (디렉토리 경로가 일종의 경로 열거 형태)

데이터 노드의 경로도 root 부터 시작해 `/`로 구분하여 하나의 속성으로 저장가능하다.

새로운 노드를 삽입할 때 다른 노드를 수정하지 않고 non-leaf 노드를 삽입할 수 있다.
(새노드의 부모 경로에 새로운 노드의 id를 덧붙이기만 하면 된다)

만약 구분자 사이 요소길이가 같은 경우 데이터를 계층구조에 따라 쉽게 정렬할 수 있다. (단순히 문자를 정렬하는 것과 같다)

경로 열거는 무단횡단과 비슷한 단점이 있다.
경로 문자열을 유지하는 것이 애플리케이션 코드에 종속되고, 검증에 비용이 많이 든다. 또한 길이도 제한된다.

#### 중첩집합(Nested Sets)

중첩 집합은 각 노드가 자신의 부모대신 자손의 집합에 대한 정보를 저장한다.

각 노드는 nleft, nright (다른이름도 상관 없음)라는 두 숫자를 가진다.
nleft는 모든 자식 노드의 nleft 수 보다 작고, lright는 모든 자식 노드의 nright 수 보다 크다.

이 경우 현재 노드의 nleft와 nright 사이의 값을, nleft 값으로 가진 노드를 찾으면 모든 자식 노드를 찾는 것이다.
반대로 nleft와 nright 사이의 값으로 현재 노드의 nleft값을 가지는 노드를 찾으면 모든 조상 노드를 찾을 수 있다.

중첩 집합 모델의 강점은, 자식을 가진 노드를 삭제 했을 때 그 자손이 자동으로 삭제 노드의 부모 자손이 된다는 점이다.

그러나 직접적인 자식이나 부모조회는 복잡하다.
어떤 노드가 직계 조상/후손 노드인지 알 수 없으므로 두 노드사이의 조상/후손이 있는 지를 비교하여 없는 경우를 찾아야 한다.

노드 추가/이동도 복잡하다. 이 경우 새 노드의 left보다 큰 모든 노드의 left, right 값을 재계산 해야 한다.

#### 클로저 테이블(Closure Table)

클로저 테이블은 부모-자식 관계의 경로만 저장하는 것이 아니라, 트리의 모든 경로를 저장한다.

대상 데이터 테이블과 두 개의 컬럼을 가진 경로 데이터 테이블을 생성한다.
트리 구조에 대한 정보를 경로 데이터 테이블에 저장한다.
이 테이블에서는 트리에서 조상/자손 관계를 가진 모든 노드쌍과 자기 자신을 참조를 각 행으로 저장한다. (각 노드는 모든 후손을 표기한다)

클로저 테이블에서 조상이나 자손을 가져오는 방식은 직관적이다.
만약 4번 데이터의 자손을 얻으려면 경로 테이블에서 조상이 4인 데이터를 찾으면 된다.

클로저 테이블은 조상/자손 조회및 계층구조 정보 유지가 쉬운편이다.

#### 모델 선택

- 인접 목록은 가장 많이 사용되는 형태
- 재귀적 쿼리는 문법을 지원하는 DBMS를 사용해야 함
- 경로열거는 참조 정합성을 강제하지 못하고 정보를 중복 저장하므로 깨지기 쉽다
- 중첩 집합역시 참조 정합성을 강제하지 못한다. 수정은 적고 조회를 주로하는 경우 좋다
- 클로저 테이블은 가장 융통성 있는 모델이나, 깊은 계층 구조 설명을 위해 많은 행이 필요하다

## ID가 필요해

모든 테이블이 PK를 가지더라도 PK 본질을 혼동하면 안된다.
까다로운 부분은 PK로 사용할 컬럼을 선정하는 일이다.

다음과 같은 것이 필요하다면 PK 제약조건이 필요한 것이다

- 테이블에 중복행이 저장되는 것을 방지
- 쿼리에서 각 행을 참조
- FK 참조 지원

그러나, 대부분의 테이블에서 어느 속성값이든 하나 이상의 행에서 나타날 가능성이 있다.
이런 테이블에는 아무런 의미도 없는 인위적 값을 저장할 필요가 있는데,
이러한 형태의 PK를 pseudo key / surrogate key 라고 한다.

여러 클라이언트가 동시에 행을 삽입하는 경우에도 각 가상키 값이 유일하게 할당되는 것을 보장하기 위해,
대부분의 DBMS는 트랜잭션 격리 범위 밖에서 유일한 정수값을 생성하는 기능을 제공한다.

### 안티패턴: 만능키

다음과 같은 특성을 가지는 PK 컬럼을 만드는 관례가 있다

- PK 컬럼 이름은 `id`이다
- PK 컬럼 데이터 타입은 32/64비트 정수이다
- 유일한 값은 자동 생성된다

모든 테이블에 `id` 컬럼을 추가하는 것은 이상한 사용 문제를 초래하기도 한다.

- 중복 키 생성
  - 테이블내 다른 컬럼이 자연키로 사용될 수 있는 상황에서도 `id` 컬럼을 PK로 정의한 경우가 있다
  - 그 컬럼에 `UNIQUE` 제약조건이 설정되어 있는 경우도 있다

- 중복 행 허용
  - 복합키는 여러 컬럼을 포함한다
  - `id` 컬럼을 PK로 사용하는 경우 유일해야 하는 복합키 조건을 만족하지 못할 수 있다
  - 이 경우 다른 복합키 후보 컬럼에 `UNIQUE` 제약조건을 걸어야 하는데 그렇다면 `id` PK는 불필요하다

- 모호한 키의 의미
  - `id`란 이름은 너무 일반적이므로 아무런 의미를 갖지 못한다
  - 이는 특히 `id` 컬럼을 가진 두 테이블을 조인할 때 문제가 된다

- USING 사용
  - `JOIN ON` 키워드를 사용하는 대신 `JOIN USING` 키워드를 사용해 간략한 문법으로 조인할 수 있다
  - 그러나 모든 테이블에서 `id`라는 PK를 사용한다면 FK컬럼과 PK컬럼의 이름이 다르므로 이 문법을 사용할 수 없다

#### 시퀀스의 특별한 범위

최댓값에 1을 더해 새 행을 위한 키 값으로 사용하는 경우가 있다

그러나 여러개의 클라이언트가 동시에 쿼리를 실행할 수 있다면 이런 방식은 안전하지 않다.
여러 클라이언트에서 같은 값을 사용할 수도 있는데, 이런 상황을 경쟁 상태(race condition)이라고 한다.

경쟁 상태를 피하려면 동시 삽입을 막고 최댓값을 구한다음 이를 이용에 행을 삽입해야 한다.
그렇게 하려면 행 수준 lock으로 충분하지 않고 전체 테이블 lock을 사용해야 한다.
테이블 lock은 클라이언트 동시 접근을 막고 요청을 순차적으로 처리하므로 병목의 원인이 된다.

시퀀스는 트랜잭션 범위 밖에서 동작해 이 문제를 해결한다.
시퀀스는 여러 클라이언트에 같은 값을 할당하지 않고,
삽입할 행에 사용한 값을 커밋했는지 여부과 상관없이 한번 할당한 값을 되돌리지도 못한다.

시퀀스는 이런 방식으로 동작하므로 여러 클라이언트가 동시에 중복되지 않은 유일한 값을 할당받는다고 확신할 수 있다.

대부분의 DBMS는 시퀀스가 생성한 마지막 값을 확인할 수 있는 함수를 제공한다.
MySQL에서는 `LAST_INSERT_ID()`, SQL Server에서는 `SCOPE_IDENTITY()`, ORACLE에서는 `시퀀스이름.CURRVAL`이다.

### 안티패턴 인식 방법: 만능키

테이블에서 PK 컬럼 이름으로 지나치게 일반적인 이름(id...)이 사용되고 있거나
다대다 연결에서 중복이 발생하는 경우 안티패턴의 징후로 볼 수 있다.

### 안티패턴 사용이 합당한 경우: 만능키

Convention으로 정해놓았거나, 지나치게 긴 자연키를 대체하기 위해 사용한다면 적절한 선택이다.

### 해법: 상황에 맞추기

PK는 제약조건이지 데이터 타입이 아니다.
데이터 타입이 인덱스를 지원하기만 하면 어느 컬럼 혹은 컬럼 묶음에 대해서 PK를 선언할 수 있다.

- 있는 그대로 말하기
  - PK에 의미있는 이름을 선택해야 한다
  - 가급적 FK에서도 가능한 같은 컬럼이름을 사용해야 한다
  - 이는 종종 PK 이름이 스키마 내에서 유일해야 함을 뜻한다

- 관례에서 벗어나기
  - ORM에서는 `id`라는 이름의 가상키가 사용될 것을 기대하지만 다른 이름으로 설정할 수도 있다

- 자연키와 복합키
  - 유일함이 보장되고 NULL인 경우가 없으며 행을 식별하는 용도로 사용될 수 있는 컬럼이 있으면 가상키를 사용할 필요는 없다
  - 그러나 처음에는 자연키로 사용될 수 있던 컬럼이 시스템이 변경됨에 따라 중복을 허용하게 될 수도 있다
  - 복합키가 적합한 경우에 이를 사용하지만, 복합키의 FK 또한 복합키가 되어야 함에 유의해야 한다

## 키가 없는 엔트리

RDBMS에서 참조정합성(Referential Integrity)은 데이터베이스 설계 및 운영에서 중요한 부분이다.
어떤 컬럼(묶음)에 FK 제약조건을 선언하면 그 컬럼에 들어가는 값은 부모테이블의 PK 또는 UNIQUE KEY에 존재해야 한다.

그러나 어떤 개발자는 참조 정합성 제약조건을 무시하라는 말을 한다. 그 이유는 다음과 같다.

- 데이터 업데이트 시 제약조건과 충돌할 수 있다
- 참조 정합성 제약족너을 지원할 수 없는 매우 융통성 있는 데이터베이스 설계를 사용하고 있다
- FK에 데이터베이스가 자동생성하는 인덱스때문에 성능에 영향이 있다고 믿는다
- FK를 지원하지 않는 데이터베이스를 사용하고 있다

### 안티패턴: 제약조건 무시

FK 제약조건을 생략하는 것이 데이터베이스 설계를 단순하고 유연하게 만드는 것처럼 보이지만 다른 대가를 치러야 한다.
참조 정합성을 보장하기 위한 코드를 직접 작성하는 책임을 떠안아야 하기 때문이다.

- 무결점 코드
  - FK 제약조건을 사용하지 않고 참조 정합성을 만족하기 위해, 변경전 별도의 SELECT 쿼리를 실행해 정합성 유지여부를 확인해야 한다.
  - 확인을 위한 쿼리를 실행한 직후 다른 클라이언트의 요청으로 해당 값이 변경되는 경우 정합성이 유지되지 않는다
  - 이를 방지하기 위한 유일한 해결책은 테이블을 잠근뒤 일련의 작업을 진행하는 것이지만, 엄청난 성능저하가 발생할 것이다

- 오류 확인
  - 깨진 참조를 수동으로 확인해야 한다면 얼마나 자주 해야하는지에 대한 의문이 있을 것이다
  - 만약 깨진 참조를 발견한다 하여도 올바르게 수정할 수 있을지 확신할 수도 없다

- 누구의 잘못인가
  - 애플리케이션이 아니라 쿼리 도구나 스크립트를 이용해서 데이터베이스를 직접 수정할 수도 있다
  - 이런 경우 깨진 참조가 발생할 가능성이 더욱크지만, 애플리케이션 수명주기상 이런 일이 발생할 수도 있음을 인정해야 한다

- 진퇴양난 업데이트
  - 많은 개발자들이 여러 테이블에 걸친 관련 컬럼 업데이트가 불편하므로 FK 제약조건 사용을 꺼린다
  - 이 문제는 특히 자식행이 참조하고 있는 컬럼을 UPDATE 하려할 때 발생한다
  - 부모를 업데이트 하기 전에는 자식 행을 업데이트 할 수 없고, 자신을 참조하는 자식 행을 업데이트하기 전에는 부모를 업데이트 할 수 없다

### 안티패턴 인식 방법: 제약조건 무시

다음과 같은 경우 키가 없는 엔트리 안티패턴일 가능성이 있다

- 어떤 값이 한 테이블에는 있고 다른 테이블에 없는지 확인하려는 쿼리 작성방법을 고민
- 테이블에 삽입하면서 다른 테이블에 어떤 값이 있는지 빠르게 확인하는 방법을 고민

### 해법: 제약조건 선언하기

데이터 정합성 오류를 찾아내 정정하는 대신 FK를 사용하여 처음부터 잘못된 데이터가 입력되지 않도록 한다.
이 강제사항을 우회할 코드는 존재할 수 없다.

- 여러 테이블 변경 지원
  - FK는 애플리케이션 코드가 행할 수 없는 cascading update를 수행할 수 있다
  - 이경우 부모행을 업데이트/삭제 하는 경우 해당 행을 참조하는 자식행을 알아서 처리한다
  - FK 제약조건의 `ON UPDATE` 또는 `ON DELETE` 절을 선언하는 방식에 따라 단계적 작업 결과를 제어할 수 있다

- 오버헤드?
  - FK 제약조건에 약간의 오버헤드가 있는 것은 사실이다
  - 그러나 다른조건과 비교했을 때 FK가 훨씬 효율적이다
    - INSERT, UPDATE, DELETE 실행이전 데이터 확인을 위해 SELECT 실행 불필요(경쟁상태 문제도 발생할 수 있음)
    - 여러 테이블을 변경하기 위해 테이블 lock을 사용할 필요가 없다
    - 불필요하게 발생하는 참조가 없는 데이터를 삭제하기 위해 스크립트를 실행할 필요가 없다

## 엔티티-속성-값

일반적인 테이블은 모든 행과 관계된 속성 컬럼으로 이루어져 있고, 각 행은 비슷한 객체의 인스턴스를 나타낸다.
속성 집합이 다르면 객체의 타입도 다르다는 뜻이며, 따라서 다른 테이블에 있어야 한다.

객체지향 프로그래밍 모델에서는 동일한 데이터 타입을 확장하는 방법으로 객체의 타입도 관계를 가질 수 있다.
이 때, 객체를 하나의 데이터베이스 테이블에 행으로 저장하는경우,
각 서브타입이 베이스 타입이나 다른 서브타입에 적용되지 않는 속성을 저장하는 것(가변속성)도 허용해야 한다.

### 안티패턴: 범용 속성 테이블 사용

가변 속성을 지원해야 할 때 별도 테이블을 생성해 저장할 수 있다.
이 가변 속성 테이블의 각 행은 세 가지의 컬럼을 갖는다.

- 엔티티: 하나의 엔티티에 대해 하나의 행을 가지는 부모 테이블에 대한 FK이다
- 속성: 각 행마다 속성 하나씩 들어간다
- 값: 모든 엔티티는 각 속성에 대한 값을 가진다

이 설계는 엔티티-속성-값(Entity-Attribute-Value)라고 불린다.

별도 테이블은 다음과 같은 이득을 줄것으로 생각할 수 있다

- 객체를 확장한 데이터를 저장하는 테이블은 적은 컬럼을 갖는다
- 새로운 속성을 지원하기 위해서 컬럼 수를 늘릴필요가 없다
- 특정 속성이 해당 행에 적용되지 않을 때 `NULL`을 채워야 하는 컬럼이 발생하지 않는다

그러나 데이터베이스 설계가 단순하다고 해서 쉽게 사용할 수 있는 것은 아니다

- 속성조회
  - EAV 설계에서 필요한 값을 찾을 때 전체 행에서 해당 속성을 가진 행을 추가로 찾아야 한다
  - 이는 더 복잡하고 불명확하다

- 데이터 정합성 지원
  - 데이터베이스 설계에 적용되는 DBMS 기본 기능상 장점을 희생해야 한다
  - 필수 속성(NOT NULL) 사용 불가
  - SQL 데이터 타입 사용 불가
  - 참조 정합성 강제 불가(전체 행에서 참조정합성을 사용할 행만 선택할 수 없으므로)
  - 속성 이름 강제 불가 (속성이름도 가변이므로)

- 행 재구성
  - 행 하나의 일부로 속성을 꺼내기 위해서는 각 속성에 대한 졷인이 필요하다
  - 쿼리를 작성하는 시점에서 모든 속성의 이름을 알아야 한다
  - 속성이 늘어나면 조인도 늘어나고 쿼리의 비용은 지수적으로 증가한다

### 안티패턴 사용이 합당한 경우: 범용 속성 테이블 사용

관계형 데이터베이스에서 EAV 패턴사용을 합리화하기는 어렵다.
비관계형 데이터 관리가 필요하다면 비관계형 기술을 사용하는 것이 좋다(NoSQL...)

### 해법: 서브타입 모델링

서브타입 수에 제한이 잇고 각 서브타입의 속성을 알고 있다면, EAV 패턴을 사용하지 않아도 문제를 해결할 수 있다.

#### 단일 테이블 상속(Single Table Inheritance)

이 설계의 이름은 마틴 파울러의 Patterns of Enterprise Application Architecture에서 나왔다

- 가장 단순한 설계는 관련한 모든 타입을 하나의 테이블에 저장하고 모든 속성을 별도의 컬럼으로 가지도록 하는 것
- 해당 속성이 적용되지 않는 객체를 저장하는 경우 이런 컬럼에는 `NULL`을 넣어야 한다

단점 또한 존재한다

- 이 경우 테이블에 들어가는 컬럼 수의 실질적 한계에 직면할 수도 있다
- 또한, 어떤 속성이 어느 서브타입에 속하는지 정의하는 메타데이터가 없다. 이는 개발자가 직접 관리해야 한다.

단일 테이블 상속은 서브타입 개수가 적고 특정 서브타입에만 속하는 속성 개수가 적을 때,
그리고 액티브 레코드와 같은 단일 테이블 데이터베이스 접근 패턴을 사용해야 할 때 가장 좋다.

#### 구체 테이블 상속(Concrete Table Inheritance)

서브 타입별로 별도의 테이블을 만들 수도 있다.
공통 속성 뿐만 아니라 특정 서브타입에만 필요한 속성도 포함된다.

이 설계의 이름 역시 마틴 파울러의 책에서 나왔다.

- 특정 서브타입을 저장할 때 해당 서브타입에 적용되지 않는 속성은 저장할 수 없게 한다
- 단일 테이블 상속 설계에 잇어야 했던 각 행의 서브타입을 나타내는 부가적 속성이 필요하지 않다

이 설계 역시 단점이 있다

- 서브타입 속성에서 어떤 속성이 공통 속성인지 알기 어렵다
- 새로운 공통속성이 추가되면 모든 서브타입 테이블을 변경해야 한다
- 관련 객체가 서브타입 테이블에 저장되었다는 것을 알려주는 메타 데이터도 없다
  - 처음 관련 테이블을 보는 사람들은 공통 컬럼이 존재하는 것인지 단순히 비슷한 데이터를 가진 것인지 명확히 구분하기 어렵다
- 서브타입에 상관없이 모든 객체를 보는 것도 복잡하다
  - 이 쿼리를 쉽게 하려면 각 서브타입 테이블에서 공통 속성만 선택한 뒤 이를 UNION으로 묶은 VIEW를 정의해야 한다

구체 테이블 상속 설계는 모든 서브타입을 한번에 조회할 필요가 거의 없는 경우 적합하다

#### 클래스 테이블 상속(Class Table Inheritance)

테이블을 객체지향 클래스인 것으로 간주하여 상속을 흉내낼 수 있다.

서브타입에 공통속성을 포함하는 베이스 타입을 위한 테이블을 하나 만든다.
그리고 각 서브타입에 대한 테이블을 만든다. 서브타입 테이블의 PK는 베이스 테이블에 대한 FK역할도 수행한다.

이 설계의 이름 역시 마틴 파울러의 책에서 나왔다.

- 메타데이터에 의해 1:1 관계가 강제된다. 베이스테이블의 FK는 PK이기도 하므로 유일하기 때문이다.
- 베이스 타입에 있는 속성만 참조하는 한, 모든 서브타입 검색에 대해 효율적 방법을 제공한다.
- 베이스 테이블의 행이 어떤 서브타입을 나타내는지 알 필요가 없다
- 서브타입 개수가 적다면 각 서브타입과 조인하는 쿼리를 작성해 단일 테이블 상속과 같은 결과를 만들 수 있다

모든 서브타입에 대한 조회가 많고 공통컬럼을 참조하는 경우가 많다면 이 설계가 적합하다

#### 반구조적 데이터(Semistructured Data)

서브타입의 수가 많거나 또는 새로운 속성을 지원해야 하는 경우가 빈번하다면,
데이터의 속성 이름과 값을 XML/JSON으로 부호화해 TEXT/CLOB 컬럼으로 저장할 수 있다.

마틴 파울러는 이 패턴을 Serialized LOB라고 불렀다.

- 새로운 속성은 언제든 TEXT 컬럼에 저장할 수 있으므로 확장이 쉽다

단점은,

- 이런 구조는 SQL이 특정속성에 직접 접근하는 것을 제대로 지원하지 않는다
- TEXT 내부의 각 속성에 대해 행 기반의 제한을 하거나, 집계/정렬을 하는등의 조회가 쉽지 않다

이 설계는 서브타입 개수를 제한할 수 없고 어느때나 새로운 속성을 정의할 수 있는 완전 유연성이 필요할 때 적합하다

### 사후처리

EAV를 사용하는 레거시 프로젝트를 다룰 때는, 엔티티를 단일 행으로 조회하지 말고 그대로 한 행씩 꺼내야 한다.
해당 엔티티를 모두 조회한 뒤 어플리케이션 레벨에서 속성을 분류하여 사용하도록 해야 한다.

## 다형성 연관

댓글을 갖고 있는 두 엔티티가 있다.
엔티티는 별도의 테이블에 저장되지만 댓글은 공통으로 나타나므로 하나의 테이블에서만 관리하고자 할 수 있을 것이다.

### 안티패턴: 이중 목적의 FK 사용

이런 경우는 다형성 연관(Polymorphic Associations)이라고 불린다.

- 다형성 연관 정의
  - 다형성 연관을 작동하게 하려면 FK 컬럼 앞에 문자열 타입의 별도 컬럼이 필요하다
  - 별도 컬럼에 현재 행이 참조하는 부모 테이블 이름을 넣는다
  - FK는 하나의 테이블만 참조할 수 있으므로 사용할 수 없다
  - 다형성 연관 안티패턴과 EAV 안티패턴은 유사한 특성을 지닌다

- 다형성 연관에서의 조회
  - FK 역할을 하는 컬럼의 값은 양쪽 부모테이블에서 나타날수도 한쪽에서만 나타날수도있다
  - 따라서 부모와 자식을 조인할 때 별도 컬럼에서 정의한 타입을 정확하게 사용하는 것이 중요하다

- 관련없는 부모 테이블
  - 다형성 연관은 부모 테이블이 서로 아무런 관계가 없을 때도 사용할 수 있다 (주문/사용자 - 주소)
  - 당연히 하나의 자식을 둘 이상의 부모와 연관시킬 수 없다

### 안티패턴 사용이 합당한 경우: 이중 목적의 FK 사용

다형성 연관 안티패턴은 사용을 피하고 FK등의 제약조건을 사용해 참조 정합성을 보장해야 한다.
다형성 연관은 메타데이터 대신 애플리케이션 코드에 지나치게 의존하도록 만든다.

ORM 프레임워크를 사용하는 경우 안티패턴 사용이 불가피할 수도 있다.

### 해법: 관계 단순화

다형성 연관의 단점을 피하면서 필요한 데이터 모델을 지원하기 위해서는 데이터베이스를 다시 설계하는 것이 낫다.

#### 역참조

다형성 연관에서는 관계의 방향이 거꾸로라는 본질을 이해해야 한다

- 교차테이블 생성
  - 자식테이블의 FK는 여러 부모테이블을 참조할 수 없다
  - 대신 각 부모에 대해 교차테이블을 생성하고 교차테이블에는 부모테이블에 대한 FK와 자식에 대한 FK를 포함한다
  - 이 경우 자식테이블의 타입을 위한 추가 컬럼이 불필요하다
  - 또한 DBMS의 메타데이터로 데이터 정합성을 강제할 수 있다

- 신호등 설치
  - 이 방식의 경우 허용하고 싶지 않은 연관이 생길 수도 있다
  - 교차테이블의 경우 기본적으로 다대다 관계를 선언하기 때문이다
  - 이 경우 제한하려는 FK 컬럼에 UNIQUE 제약조건을 설정할 수도 있다
  - 그러나 이 방식으로도 자식이 부모의 교차테이블마다 한 번씩 참조되는 것을 방지하지는 못한다

- 양쪽 다 보기
  - 여러 부모와 연관된 자식을 부모와 함께 보려면 여러 교차 테이블로 외부조인을 사용한다
  - 여러 부모테이블을 지정해야 하지만 다형성 연관 안티패턴처럼 쿼리가 복잡하지는 않다

- 차선 통합
  - 여러 부모테이블에 대해 조회한 결과를 하나의 테이블에서 조회한 것처럼 보이게 할 필요가 있다
  - UNION으로 결과를 묶는다면 컬럼 개수와 데이터 타입이 같아야 한다
  - 한 방법은 한 쪽 테이블에만 존재하는 컬럼에 대해서 NULL을 만들어준다 (`SELECT NULL as foo`)
  - 다른 방법은 처음으로 NULL이 아닌 인자를 반환하는 `COALESCE()` 함수를 사용하는 것이다 (`COALESCE(a.foo, b.foo) as bar`)
  - 쿼리가 복잡하므로 뷰로 만들어 애플리케이션에서 사용하자

#### 공통 수퍼테이블 생성

객체지향 다형성에서는 서브타입이 공통의 수퍼타입을 공유하므로 두 서브타입을 비슷하게 참조할 수 있다.
다형성 연관 안티패턴에서는 수퍼타입이 없는데, 모든 부모테이블이 상속할 base table을 생성해 사용할 수 있다.

자식테이블에 베이스테이블을 참조하는 FK를 추가한다(타입을 위한 별도 컬럼은 필요없다)

이 경우 특정 자식이 참조하는 여러 부모를 비교적 간단하게 조회할 수 있다.
또한 베이스테이블과 부모테이블의 PK가 같으므로 부모테이블과 자식테이블도 직접 조인할 수 있다.
마찬가지로, 특정 부모의 자식도 쉽게 조회할 수 있다.

## 다중 컬럼 속성

속성이 여러값을 가지는 데 한 테이블에 들어가는 경우, 앞의 무단횡단 안티패턴과 유사한 문제가 발생한다.

### 안티패턴: 여러 개의 컬럼 생성

속성에 여러 값이 들어가는 것을 고려해야 하지만, 각 컬럼에는 하나의 값만을 저장해야 한다.
이 경우 여러 컬럼을 만들어(col1, col2, col3 ...) 값을 저장하고 사용하지 않은 컬럼은 `NULL`로 둔다.

- 값 검색
  - 주어진 값을 찾으려면 하나 이상의 컬럼을 모두 확인해야 한다
  - `OR` 조건을 사용해서 여러 컬럼을 검색한다 (`OR`는 `AND` 보다 우선순위가 낮음에 주의)

- 값 추가와 삭제
  - 어느 컬럼이 비어있는지 알 수 없으므로 단순히 `UPDATE`를 사용하는 것은 안전하지 않다
  - 다른 클라이이언트가 접근하여 동일 행을 갱신한다면 충돌이 발생한다

- 유일성 보장
  - 동일 값이 여러 컬럼 속성에 나타나는 것을 막지 못한다

- 값의 수 증가 처리
  - 사전에 생성해 둔 컬럼 숫자가 부족할 수 있다
  - 필요에 따라 테이블을 확장하는 것은 많은 비용을 수반한다
  - 해당 테이블을 사용하는 애플리케이션에서 추가한 컬럼을 지원하도록 코드를 수정해야 한다

### 안티패턴 사용이 합당한 경우: 여러 개의 컬럼 생성

속성의 개수가 고정되고 위치나 순서가 중요한 경우가 있을 수 있다.
조회의 복잡성이 있더라도 다른 경우의 단순함을 위해 이런 구조를 수용할 수 있다.

### 해법: 종속 테이블 생성

가장 좋은 해법은 다중 값 속성을 위한 컬럼을 하나 가지는 종속 테이블을 만드는 것이다.
여러 값을 여러 컬럼 대신 여러 행에 저장한다.
또한 종속 테이블에 FK를 정의해 해당 값이 부모 행과 연관되도록 한다.

## 메타데이터 트리블(Metadata Tribble)

데이터 양이 늘어나면 어떤 쿼리든 성능이 떨어진다.

### 안티패턴: 테이블 또는 컬럼 복제

트리블(tribble)은 스타트랙에서 나오는 번식력 강한 동물이다.
다른 모든 조건이 동일하다면, 행이 적은 테이블을 조회하는 것이 더 빠르다.

- 테이블 분리
  - 많은 행을 가진 큰 테이블을 여러 개의 작은 테이블로 분리한다
  - 분리한 테이블 이름은 기존 테이블 속성 중 하나의 값을 기준으로 한다
- 컬럼 분리
  - 하나의 컬럼을 여러개의 컬럼으로 분리한다
  - 컬럼 일므은 다른 속성값을 기준으로 한다

이를 위해서는 지나치게 많은 컬럼을 가진 테이블을 생성하거나 엄청나게 많은 테이블을 생성해야 한다.

- 지나치게 많은 테이블
  - 연도 같은 값을 기준으로 테이블을 분리할 수 있다
  - 값에 따라 올바른 테이블을 선택하는 것은 사용자 책임이된다
  - 연말이 지나 새로운 연도가 되었을 때, 다음 연도 테이블이 없다면 에러가 발생한다

- 데이터 정합성 관리
  - 특정연도 테이블에 이전 연도 자료가 들어갈 수도 있다
  - 테이블 이름에 맞춰 제한할 수는 없지만 각 테이블에서 `CHECK` 제약조건을 선언할 수는 있다

- 데이터 동기화
  - 날짜를 변경했다고 가정하자, 날짜가 이전년도로 바뀌었다면 테이블이 변경되어야 한다
  - 결국 `UPDATE` 대신 삭제 후 삽입을 실행해야 한다

- 유일성 보장
  - PK 값은 모든 분할된 테이블에 걸쳐 유일서응ㄹ 보장받아야 한다
  - 시퀀스를 별도로 지원한다면 하나의 시퀀스를 사용하면 된다
  - 다른 경우는 PK만을 위한 테이블을 관리해야 할 것이다

- 여러 테이블에 걸쳐 조회
  - 불가피하게 여러 테이블에 걸쳐 데이터를 조회한다면 `UNION`으로 묶어 쿼리를 실행해야 한다

- 메타데이터 동기화
  - 특정 테이블에서 필요에 따라 컬럼을 추가할 수 있다
  - 다른 테이블을 그냥 둘 수도 있지만, `UNION`등을 사용해서 함께 사용하는 경우가 있다면 이에 맞춰 대응해야 한다

- 참조 정합성 관리
  - 자식테이블을 갖고 있는 경우 분할하였다면 FK를 사용할 수 없다
  - FK는 하나의 부모테이블을 대상으로 지정 가능하다
  - 분할대상이 자식테이블이어도 문제가 발생한다
  - 부모 데이터에 해당하는 자식을 모두 조회하려면 복잡한 쿼리 작성이 필요하다

- 메타데이터 트리블 컬럼 식별
  - 컬럼도 동일한 형태로 메타데이터 트리블이 될 수 있다

### 안티패턴 사용이 합당한 경우: 테이블 또는 컬럼 복제

자주 사용하는 데이터와 오래된 데이터를 분리해 별도 보관하는 방식으로 수동 분할 할 수 있다.
두 종류의 데이터를 함께 조회할 필요가 없다면 오래된 데이터는 옮기고 삭제하는 것이 적절하다.

### 해법: 파티션과 정규화

테이블이 매우 커졌을 때 테이블 직접 분리보다 좋은 방법이 있다

#### 수평 분할(Horizontal partitioning)

수평 분할에서는 행을 여러 파티션으로 분리하는 규칙과 함께 논리 테이블을 하나 정의하면 DBMS가 알아서 처리한다.
테이블은 분리되어 있지만 SQL에서는 하나의 테이블처럼 사용할 수 있다.

MySQL의 파티셔닝 같은 기능으로 각 테이블에서 각 행을 별도 스토리지로 분리하는 방식도 정의할 수 있다.

#### 수직 분할(Vertical partitioning)

수평 분할은 테이블을 행으로 나누고, 수직 분할은 컬럼으로 테이블을 나눈다.
컬럼으로 테이블을 나누는 방법은 크기가 큰 컬럼이나 거의 사용되지 않는 컬럼이 있을 때 유용하다.

BLOB, TEXT는 크기가 가변적이고 매우 커질 수 있다.
테이블의 BLOB, TEXT를 참조하지 않는 쿼리를 실행하면 다른 컬럼에 효율적으로 접근할 수 있다.

일반적으로 테이블을 조회할 때 wildcard(*)를 사용하지 않고, 컬럼을 명시한다면 해당 컬럼을 배제할 수 있다.
다른 방식으로는, 해당 테이블에 종속된 추가 테이블을 생성하고 FK를 사용해 BLOB, TEXT를 별도 저장한다.

#### 메타데이터 트리블 컬럼 고치기

다중 컬럼 속상과 비슷하게 메타데이터 트리블 컬럼에 대한 해결 방법도 종속 테이블을 생성하는 것이다.

## 반올림 오류

정수가 아닌 수를 저장하고 이를 산술연산에 사용하는데, 산술연산의 결과가 정확해야 한다.

### 안티패턴: FLOAT 데이터 타입 사용

대부분의 프로그래밍 언어는 float, double 같은 실수를 표현하는 데이터 타입을 지원한다.
SQL도 마찬가지로 비슷한 데이터타입을 비슷한 이름으로 제공한다.

SQL의 FLOAT 데이터 타입은 다른 프로그래밍 언어와 마찬가지로 IEEE 754 표준에 의해 실수를 이진형식으로 부호화한다.
이 데이터 타입을 정확히 사용하려면, 부동 소수점 특성을 이해해야 한다.

- 필요에 의한 반올림
  - 부동 소수점의 특성상 어떤 십진수는 이진수로 표현할 수 없다
  - 무한 소수는 무한대의 자리수가 필요하므로 근사값으로 저장될 것이다
  - IEEE 754에서 부동 소수점은 밑수가 2인 형식이므로, 10진수에서 유한해도 정확한 표현을 할 수 없을 때가 있다
  - FLOAT을 애플리케이션에서 사용할 때는 어떤 값이든 반올림 된 상태라는 가정을 해야 한다

- SQL에서 FLOAT 사용
  - 어떤 데이터베이스는 값을 보정해 표현하기도 한다, 그러나 정확한 값을 가지고 있는 것은 아니다
  - 이러한 오차는 합과 곱에서 중복 발생하므로 계산마다 커지게 된다 (곱의 경우 엄청난 차이가 누적된다)
  - 만약 동등비교에 이 값을 사용한다면 부정확한 결과가 출력된다
  - 문제를 회피하는 방법은 두 값의 차이의 절대값을 구한다음 오차 범위보다 작은지 확인하는 것이다 (`a - b < 0.00001`)

### 안티패턴 인식 방법: FLOAT 데이터 타입 사용

FLOAT, REAL, DOUBLE, PRECISION 데이터 타입이 사용되는 곳이면 어디든 오류의 후보이다.

### 해법: NUMERIC 데이터 타입 사용

고정 소수점은 FLOAT 혹은 유사 타입대신 NUMERIC 또는 DECIMAL 타입을 사용해야 한다.
이런 데이터 타입은 컬럼에서 지정한 정도까지 정확한 수치를 표현한다.

NUMERIC/DECIMAL 타입은 저장될 때 이진변환시 반올림 되지 않고 정확히 저장된다.

## 31가지 맛

컬럼의 값을 고정된 집합의 값으로 제한하는 것은 유용하다. (유효성 관리)

### 안티패턴: 컬럼 정의에 값 지정

컬럼을 정의할 때 유효한 데이터 값을 지정하는 경우가 있다. (테이블 구조 정의)

MySQL은 컬럼을 특정 값의 집합으로 제한하는 ENUM이라는 비표준 데이터 타입을 지원한다.
값의 선언은 문자열 이지만, 내부적으로는 해당 문자열이 몇 번째인지를 나타내는 ordinal number로 저장하도록 되어있다.

미리 혀용한 값을 검사하는 트리거를 사용할 수도 있다.

- 중간에 있는 값은?
  - 아직까지는 특정 값만 저쟝되어, 전체 목록을 보려면 데이터베이스 메타데이터를 조회해야 할 수도 있다

- 새로운 종류 추가
  - ENUM이나 CHECK 제약조건에 값을 추가하거나 삭제하는 문법은 없다 (재정의 해야한다)
  - 어떤 DBMS에서는 테이블이 비어있지 않으면 컬럼 정의를 변경할 수 없다
  - 메타데이터를 변경하는 것은 드물어야 하고 주의를 요한다

- 이전 값의 제거
  - 값을 더 이상 사용하지 않게 만들면 과거 데이터가 망가질 수 있다
  - 과거 값을 위해 제약을 그대로 둔다면, 활성 제약이 어떤 것인지 구분하기 어렵다

- 포팅이 어렵다
  - 제약은 여러 DBMS에서 균일하게 지원하는 기능이 아니다
  - 다른 DBMS를 지원해야 할 필요가 있는 경우 사용이 어렵다

### 안티패턴 인식 방법: 컬럼 정의에 값 지정

ENUM이나 CHECK 제약조건을 사용할 때는 값의 집합이 변할 것 같은지 사전 고려해야 한다.

### 해법: 데이터로 값을 지정하기

컬럼 값을 제한할 컬럼에 들어갈 데이터를 행으로 하는 색인 테이블을 생성하고, 색인 테이블을 참조하도록 FK 제약조건을 설정한다.

- 값의 집합 쿼리
  - 허용된 값의 집합은 메타데이터가 아니라 데이터이다
  - 다른 테이블을 조회할 때처럼 값의 집합을 쉽게 조회할 수 있다

- 색인 테이블 값 갱신
  - 색인 값을 쉽게 갱신할 수 있다
  - FK를 `ON UPDATE CASCADE` 옵션으로 선언했다면 값의 이름도 쉽게 바꿀 수 있다

- 더 이상 사용하지 않는 값 지원
  - 참조되는 곳이 있는한 색인 테이블에서 데이터 삭제가 불가능하다
  - 색인 테이블에 컬럼을 추가해 사용여부를 표시할 수 있다

## 유령 파일

이미지를 저장하고 이를 데이터베이스 엔티티와 연관을 갖게 하는 경우가 있다

### 안티패턴: 파일을 사용해야 한다고 가정한다

개념적으로 이미지는 테이블의 속성이다.
이미지에 대한 데이터 타입 선정은 논란이 있는 주제이다.

이미지의 바이너리 데이터는 BLOB 데이터 타입에 저장될 수 있다.
그러나 많은 경우 이미지를 파일 시스템에 파일로 저장하고 파일에 대한 경로만 VARCHAR로 데이터베이스에 저장한다.

일반적으로 파일을 데이터 베이스 밖에 저장해야 한다는 의견이 있다.

- DELETE 문제
  - 데이터베이스에서 이미지를 참조하는 행을 삭제할 때
  - 이미지 파일도 함께 삭제하도록 애플리케이션을 설계하지 않는다면
  - 참조가 없는 이미지 파일들이 계속 쌓일 것이다

- TRANSACTION 문제
  - 파일을 삭제하면 즉시 다른 클라이언트에서 접근하지 못한다
  - 이는 트랜잭션이 아직 커밋되지 않은 상태라고 그렇다
  - 트랜잭션이 실패한다면 이미지 누락이 발생한다

- ROLLBACK 문제
  - 에러가 발생한 경우 또는 애플리케이션 로직이 변경사항을 취소하는 경우 트랜잭션을 롤백하는 것이 보통이다
  - 데이터베이스에서는 롤백이 적용되지만 지워진 파일은 되살아나지 않는다

- BACKUP 문제
  - DBMS는 데이터베이스 백업을 위한 클라이언트 도구를 제공한다
  - 백업도구는 테이블에 문자열로 가지고 있는 파일 경로를 포함하는 방법을 모른다
  - 백업 이후에도 파일시스템은 별도로 변하기 때문에 데이터가 제대로 동기화 되지 않는다

- SQL 접근권한 문제
  - 외부 파일은 GRANT/REVOKE 같은 DBMS의 접근권한을 우회한다

- SQL 데이터 타입 문제
  - 데이터 베이스의 파일 경로는 문자열일 뿐이다
  - 문자열을 경로로 다루는 로직은 애플리케이션 코드에 의존할 수 밖에 없다

### 안티패턴 사용이 합당한 경우: 파일을 사용해야 한다고 가정한다

- 이미지가 없다면 데이터베이스가 훨씬 가벼워진다
- 이미지를 제외하면 데이터베이스 백업이 빨라지고 크기도 작아진다
- 데이터 베이스 외부의 파일로 존재하면 이미지 미리보기나 편집이 쉽다

어떤 DBMS는 투명하게 외부 파일을 참조하는 특수 데이터 타입을 지원한다 (Oracle의 BFILE ...)

### 해법: 필요한 경우에는 BLOB 데이터 타입을 사용하라

안티패턴에 해당하는 것이 있다면, 이미지를 외부 파일이 아닌 데이터베이스 내부에 저장하는 것을 고려해야한다.

모든 데이터베이스 제품은 바이너리 데이터 저장에 사용할 수 있는 BLOB 데이터 타입을 지원한다.

어떤 DBMS는 외부 파일을 불러오는 함수를 제공한다 (MySQL `LOAD_FILE()` ...)
반대로 BLOB을 이미지파일로 내보낼 수도 있다 (`SELECT ~ INTO DUMPFILE ~`)

## 인덱스 샷건

데이터베이스 성능을 향상시키는 가장 좋은 방법은 인덱스를 잘 활용하는 것이다.

### 안티패턴: 무계획하게 인덱스 사용하기

인덱스를 언제 사용하는지 오해하면 다음 실수를 하게 된다

- 인덱스를 불충분하게 정의하거나 아예 정의하지 않는다
- 너무 많은 인덱스를 정의하거나 도움이 되지 않는 인덱스를 정의한다
- 어떤 인덱스도 활용되지 않는 쿼리를 실행한다

#### 없는 인덱스

인덱스를 최신으로 유지하는데 오버헤드가 있다는 이야기를 듣곤한다.
우리는 오버헤드가 낭비를 뜻한다고 생각하도록 훈련되었다. 따라서 오버헤드를 제거하고 싶어한다.

오버헤드는 낭비가 아니다.
일반적인 애플리케이션의 경우 테이블을 한 번 업데이트할 때 조회는 백번은 할 것이다.

인덱스를 사용하는 쿼리를 실행할 때마다, 인덱스를 유지하는데 드는 오버헤드를 상쇄하고도 남을 이득을 얻는다.
또한 인덱스는 원하는 행을 빨리 찾게 하므로 UPDATE, DELETE에도 도움을 준다.

> 인덱스는 ANSI SQL 표준에 명시되어 있지 않으므로, 벤더사마다 각자의 구현이 있다

#### 너무 많은 인덱스

인덱스를 사용하는 쿼리를 실행해야 인덱스에 의미가 있다

- PK: 대부분의 데이터베이스는 PK에 대해 자동으로 인덱스를 생성하므로 PK에 대한 추가 인덱스는 불필요하다
- 긴 문자열 타입: 긴 문자열타입에 대한 인덱스는 유지비용이 크다
- 검색 조건이 되지 않을 컬럼
- 복합 인덱스: 복합 인덱스에서는 컬럼 순서가 중요하다. 검색조건, 조인조건, 정렬조건에 맞춰 순서를 정해야 한다.

#### 인덱스가 도움이 되지 않는 경우

아무런 인덱스도 사용하지 않는 쿼리를 실행하는 경우가 있다

- 복합 인덱스의 순서를 따르지 않고 검색, 조인, 정렬을 요청하는 경우
- 수식이나 계산된 컬럼에 대해 인덱스를 사용하려 하는 경우 (DBMS에 따라 지원범위가 다르다)
- 복합 검색조건에서 부분적으로만 인덱스가 사용되는 경우
- 인덱스가 적용되어 있지만 전방(`like '%foobar'`) 및 전후방(`like '%foobar%'`) 일치 검색을 하는 경우

### 안티패턴 인식 방법

cardinality(selectivity)는 테이블 전체 행 수와 인덱스에 구별되는 항목수의 비율이다.

cardinality가 낮으면 비효율적인 인덱스이다.
인덱스를 통해 선택된 데이터가 지나치게 많다면 추가적인 데이터 탐색을 위한 비용이 커진다.

### 해법: 인덱스를 MENTOR

데이터베이스를 분석해 좋은 인덱스를 선정하기 위한 체크리스트를 기억하기위해
MENTOR(Measure, Explain, Nominate, Test, Optimize, Rebuild)를 사용한다.

#### MEASURE

대부분의 DBMS는 SQL 쿼리가 실행된 시간을 로그로 남기므로, 비용이 많이드는 작업을 알아낼 수 있다.

- SQL Server, Oracle: SQL Server Profiler, TKProf
- MySQL, PostgreSQL: slow query log, pgFouine

애플리케이션에서 가장 시간이 많이 소요되는 쿼리가 드물게 실행되는 쿼리라면, 가장 고비용의 쿼리가 아닐 수 있다.
자주 실행되는데 비용이 많이 발생하는 쿼리를 찾아야 한다.

쿼리 성능을 측정할 때는 쿼리 결과 캐싱 기능을 비활성화 시켜야 한다.
캐싱 기능은 쿼리 실행과 인덱스 사용을 우회할 수 있으므로 측정에 방해가 된다.

#### EXPLAIN

비용이 많이 드는 쿼리를 확인했으면 쿼리가 느린 이유를 찾아야 한다.

모든 데이터베이스는 optimizer를 통해 쿼리가 사용할 인덱스를 고른다.
데이터베이스의 분석결과를 리포트로 볼 수 있는데, 이를 쿼리 실행 계획 (Query Execution Plan)이라 한다.

실행 계획을 요청하는 문법은 DBMS마다 다르다

- DB2, MySQL, PostgreSQL, SQLite: EXPLAIN
- SQL Server: DISPLAY EXECUTION PLAN
- Oracle: EXPLAIN PLAN

쿼리 실행계획에 포함되는 정보나 리포트 형식에 대한 표준은 없다.
보통, 실행계획은 쿼리에 어떤 테이블이 관련되어 있는지, 옵티마이저가 사용할 인덱스를 어떻게 선택하는지, 테이블에 어떤 순서로 접근하는지를 보여준다.

#### NOMINATE

옵티마이저의 실행계획을 확인했으면, 쿼리에서 인덱스를 사용하지 않고 테이블에 접근하는 부분을 찾아야 한다.
어떤 DBMS는 이런 작업을 대신 해주는 도구를 가지고 있다

> 커버링인덱스(Covering Index): 인덱스에서 필요한 컬럼 데이터를 추가로 제공하면 테이블에서 행을 읽을 필요가 없다.

#### TEST

인덱스를 생성한 후 쿼리를 다시 프로파일링 해야 한다.

#### OPTIMIZE

인덱스는 빈번하게 사용되는 데이터 구조로, 캐시 메모리에 보관할 좋은 후보이다.
데이터베이스 서버는 시스템 메모리의 일정량을 캐싱에 할당하도록 설정할 수 있다.

대부분의 데이터베이스는 다양한 시스템에서 잘 동작하는 것을 보장하기 위해 캐시 버퍼 크기가 작게 설정되어 있다.
캐시에 얼마나 많은 메모리를 할당해야 하는지에 대한 정답은 없다.

#### REBUILD

인덱스는 균형잡혀있을 때 가장 효율이 좋다.
시간이 지나면서 데이터를 변경함에 따라 인덱스도 점차 균형을 잃는다.
따라서 주기적으로 인덱스를 정비해야 할 필요가 있다.

인덱스 정비기능도 DBMS에 따라 용어, 문법, 특성이 다르다

- DB2: REBUILD INDEX
- SQL SERVER: ALTER INDEX ~ REORGANIZE(REBUILD)
- MySQL: ANALYZE(OPTIMIZE) TABLE
- Oracle: ALTER INDEX ~ REBUILD
- PostgreSQL VACUUM(ANALYZE)
- SQLite: VACUUM

## 모르는 것에 대한 두려움
