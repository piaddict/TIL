# SQL Anti Patterns

## 무단횡단

다대다 관계를 위한 교차테이블 생성을 피하기 위해 쉼표로 구분된 목록을 사용하는 경우

### 안티패턴: 쉼표로 구분된 목록에 저장

- 해당 데이터에서 일치하는 데이터를 검색하는 경우
- 해당 데이터를 FK로 사용해서 연관 데이터를 조회하는 경우 조인 자체도 어려울 뿐더러 조인시 인덱스를 활용할 기회가 사라진다
- 집계쿼리는 행의 그룹에 대해 사용하도록 되어 있으므로 사용이 어렵다
- 데이터 목록 정렬이 어렵다
- 연관 데이터의 갱신이 어렵다
- 입력 데이터의 유효성 검증이 어렵다
- 구분자 문자로 어떤것을 선택해야 할지에 대한 문제(comma를 사용한다면 본문의 comma는 어떻게 처리할 것인가?)
- 데이터 타입에 따라 목록 저장 길이 제한이 존재한다

### 쉼표로 구분된 목록 저장 사용이 합당한 경우

- 특정 쿼리는 역정규화를 적용해 성능을 높일 수 있다
- 이 경우 목록안의 개별항목에 접근할 필요가 없어야 한다
- 역정규화 적용은 보수적으로 접근해야 한다

### 해법: 교차 테이블 생성

- 어떤 테이블이 FK로 두 테이블을 참조할 때 이를 교차 테이블이라 한다
- 별도의 테이블에 각각의 행으로 저장하고 두 테이블 사이 다대다 관계를 생성한다
- 목록에 항목 추가/삭제는 교차 테이블에 행 삽입 삭제로 할 수 있다

## 순진한 트리

데이터가 재귀적 관계를 가지는 것은 흔한일이다. 데이터는 트리나 계층적 구조가 될 수 있다.
이러한 데이터를 조회할 때는 개별항목을 조회, 관련 부분만 조회, 전체를 조회하는 경우가 존재한다.

무한 계층 댓글, 조직도 등이 해당 자료구조라 할 수 있다.

### 안티패턴: 항상 부모에 의존

- 계층 데이터를 저장할 때 부모 데이터 id를 갖고 있는 방식의 설계를 인접 목록 (adjacency list)라 한다
- 인접목록에서 모든 자식 조회하기를 제대로 수행하지 못한다면 안티패턴이 된다
  - JOIN은 횟수가 정해져 있으므로 모든 계층을 가져온다면 많은 수행이 필요하고, 계층 제한이 없다면 실행조차 어렵다
  - 전체 데이터를 가져와 애플리케이션에서 계층을 생성하는 것은 느리고 매우 비효율적이다
- 인접 목록에서 노드 추가나 이동은 간단한 편이다. 그러나 삭제는 상당히 복잡하다.

### 항상 부모에 의존 사용이 합당한 경우

주어진 노드의 부모나 자식을 바로 얻거나 새로운 노드 추가만 주로 이루어지는 경우 인접목록 사용이 적합할 수도 있다.

어떤 DBMS는 인접 목록 형식으로 젖아된 계층 구조를 지원하기 위한 SQL 확장기능을 지원한다.
SQL-99 표준에는 WITH 키워드에 Common Table Expression을 사용한 재퀴적 쿼리문법이 있다.

### 해법: 대안 트리 모델 사용

계층 데이터 저장시 인접 목록의 대안으로 경로 열거, 중첩집합, 클로저 테이블 등이 있다.

#### 경로 열거(Path Enumeration)

인접목록의 약점중 하나는 트리에서 노드의 조상을 얻는데 비용이 크다는 것이다.
경로 열거 방법에서는 일련의 조상을 각 노드의 속성으로 저장해서 해결한다. (디렉토리 경로가 일종의 경로 열거 형태)

데이터 노드의 경로도 root 부터 시작해 `/`로 구분하여 하나의 속성으로 저장가능하다.

새로운 노드를 삽입할 때 다른 노드를 수정하지 않고 non-leaf 노드를 삽입할 수 있다.
(새노드의 부모 경로에 새로운 노드의 id를 덧붙이기만 하면 된다)

만약 구분자 사이 요소길이가 같은 경우 데이터를 계층구조에 따라 쉽게 정렬할 수 있다. (단순히 문자를 정렬하는 것과 같다)

경로 열거는 무단횡단과 비슷한 단점이 있다.
경로 문자열을 유지하는 것이 애플리케이션 코드에 종속되고, 검증에 비용이 많이 든다. 또한 길이도 제한된다.

#### 중첩집합(Nested Sets)

중첩 집합은 각 노드가 자신의 부모대신 자손의 집합에 대한 정보를 저장한다.

각 노드는 nleft, nright (다른이름도 상관 없음)라는 두 숫자를 가진다.
nleft는 모든 자식 노드의 nleft 수 보다 작고, lright는 모든 자식 노드의 nright 수 보다 크다.

이 경우 현재 노드의 nleft와 nright 사이의 값을, nleft 값으로 가진 노드를 찾으면 모든 자식 노드를 찾는 것이다.
반대로 nleft와 nright 사이의 값으로 현재 노드의 nleft값을 가지는 노드를 찾으면 모든 조상 노드를 찾을 수 있다.

중첩 집합 모델의 강점은, 자식을 가진 노드를 삭제 했을 때 그 자손이 자동으로 삭제 노드의 부모 자손이 된다는 점이다.

그러나 직접적인 자식이나 부모조회는 복잡하다.
어떤 노드가 직계 조상/후손 노드인지 알 수 없으므로 두 노드사이의 조상/후손이 있는 지를 비교하여 없는 경우를 찾아야 한다.

노드 추가/이동도 복잡하다. 이 경우 새 노드의 left보다 큰 모든 노드의 left, right 값을 재계산 해야 한다.

#### 클로저 테이블(Closure Table)

클로저 테이블은 부모-자식 관계의 경로만 저장하는 것이 아니라, 트리의 모든 경로를 저장한다.

대상 데이터 테이블과 두 개의 컬럼을 가진 경로 데이터 테이블을 생성한다.
트리 구조에 대한 정보를 경로 데이터 테이블에 저장한다.
이 테이블에서는 트리에서 조상/자손 관계를 가진 모든 노드쌍과 자기 자신을 참조를 각 행으로 저장한다. (각 노드는 모든 후손을 표기한다)

클로저 테이블에서 조상이나 자손을 가져오는 방식은 직관적이다.
만약 4번 데이터의 자손을 얻으려면 경로 테이블에서 조상이 4인 데이터를 찾으면 된다.

클로저 테이블은 조상/자손 조회및 계층구조 정보 유지가 쉬운편이다.

#### 모델 선택

- 인접 목록은 가장 많이 사용되는 형태
- 재귀적 쿼리는 문법을 지원하는 DBMS를 사용해야 함
- 경로열거는 참조 정합성을 강제하지 못하고 정보를 중복 저장하므로 깨지기 쉽다
- 중첩 집합역시 참조 정합성을 강제하지 못한다. 수정은 적고 조회를 주로하는 경우 좋다
- 클로저 테이블은 가장 융통성 있는 모델이나, 깊은 계층 구조 설명을 위해 많은 행이 필요하다

## ID가 필요해

모든 테이블이 PK를 가지더라도 PK 본질을 혼동하면 안된다.
까다로운 부분은 PK로 사용할 컬럼을 선정하는 일이다.

다음과 같은 것이 필요하다면 PK 제약조건이 필요한 것이다

- 테이블에 중복행이 저장되는 것을 방지
- 쿼리에서 각 행을 참조
- FK 참조 지원

그러나, 대부분의 테이블에서 어느 속성값이든 하나 이상의 행에서 나타날 가능성이 있다.
이런 테이블에는 아무런 의미도 없는 인위적 값을 저장할 필요가 있는데,
이러한 형태의 PK를 pseudo key / surrogate key 라고 한다.

여러 클라이언트가 동시에 행을 삽입하는 경우에도 각 가상키 값이 유일하게 할당되는 것을 보장하기 위해,
대부분의 DBMS는 트랜잭션 격리 범위 밖에서 유일한 정수값을 생성하는 기능을 제공한다.

### 안티패턴: 만능키

다음과 같은 특성을 가지는 PK 컬럼을 만드는 관례가 있다

- PK 컬럼 이름은 `id`이다
- PK 컬럼 데이터 타입은 32/64비트 정수이다
- 유일한 값은 자동 생성된다

모든 테이블에 `id` 컬럼을 추가하는 것은 이상한 사용 문제를 초래하기도 한다.

- 중복 키 생성
  - 테이블내 다른 컬럼이 자연키로 사용될 수 있는 상황에서도 `id` 컬럼을 PK로 정의한 경우가 있다
  - 그 컬럼에 `UNIQUE` 제약조건이 설정되어 있는 경우도 있다

- 중복 행 허용
  - 복합키는 여러 컬럼을 포함한다
  - `id` 컬럼을 PK로 사용하는 경우 유일해야 하는 복합키 조건을 만족하지 못할 수 있다
  - 이 경우 다른 복합키 후보 컬럼에 `UNIQUE` 제약조건을 걸어야 하는데 그렇다면 `id` PK는 불필요하다

- 모호한 키의 의미
  - `id`란 이름은 너무 일반적이므로 아무런 의미를 갖지 못한다
  - 이는 특히 `id` 컬럼을 가진 두 테이블을 조인할 때 문제가 된다

- USING 사용
  - `JOIN ON` 키워드를 사용하는 대신 `JOIN USING` 키워드를 사용해 간략한 문법으로 조인할 수 있다
  - 그러나 모든 테이블에서 `id`라는 PK를 사용한다면 FK컬럼과 PK컬럼의 이름이 다르므로 이 문법을 사용할 수 없다

#### 시퀀스의 특별한 범위

최댓값에 1을 더해 새 행을 위한 키 값으로 사용하는 경우가 있다

그러나 여러개의 클라이언트가 동시에 쿼리를 실행할 수 있다면 이런 방식은 안전하지 않다.
여러 클라이언트에서 같은 값을 사용할 수도 있는데, 이런 상황을 경쟁 상태(race condition)이라고 한다.

경쟁 상태를 피하려면 동시 삽입을 막고 최댓값을 구한다음 이를 이용에 행을 삽입해야 한다.
그렇게 하려면 행 수준 lock으로 충분하지 않고 전체 테이블 lock을 사용해야 한다.
테이블 lock은 클라이언트 동시 접근을 막고 요청을 순차적으로 처리하므로 병목의 원인이 된다.

시퀀스는 트랜잭션 범위 밖에서 동작해 이 문제를 해결한다.
시퀀스는 여러 클라이언트에 같은 값을 할당하지 않고,
삽입할 행에 사용한 값을 커밋했는지 여부과 상관없이 한번 할당한 값을 되돌리지도 못한다.

시퀀스는 이런 방식으로 동작하므로 여러 클라이언트가 동시에 중복되지 않은 유일한 값을 할당받는다고 확신할 수 있다.

대부분의 DBMS는 시퀀스가 생성한 마지막 값을 확인할 수 있는 함수를 제공한다.
MySQL에서는 `LAST_INSERT_ID()`, SQL Server에서는 `SCOPE_IDENTITY()`, ORACLE에서는 `시퀀스이름.CURRVAL`이다.

### 안티패턴 인식 방법: 만능키

테이블에서 PK 컬럼 이름으로 지나치게 일반적인 이름(id...)이 사용되고 있거나
다대다 연결에서 중복이 발생하는 경우 안티패턴의 징후로 볼 수 있다.

### 안티패턴 사용이 합당한 경우: 만능키

Convention으로 정해놓았거나, 지나치게 긴 자연키를 대체하기 위해 사용한다면 적절한 선택이다.

### 해법: 상황에 맞추기

PK는 제약조건이지 데이터 타입이 아니다.
데이터 타입이 인덱스를 지원하기만 하면 어느 컬럼 혹은 컬럼 묶음에 대해서 PK를 선언할 수 있다.

- 있는 그대로 말하기
  - PK에 의미있는 이름을 선택해야 한다
  - 가급적 FK에서도 가능한 같은 컬럼이름을 사용해야 한다
  - 이는 종종 PK 이름이 스키마 내에서 유일해야 함을 뜻한다

- 관례에서 벗어나기
  - ORM에서는 `id`라는 이름의 가상키가 사용될 것을 기대하지만 다른 이름으로 설정할 수도 있다

- 자연키와 복합키
  - 유일함이 보장되고 NULL인 경우가 없으며 행을 식별하는 용도로 사용될 수 있는 컬럼이 있으면 가상키를 사용할 필요는 없다
  - 그러나 처음에는 자연키로 사용될 수 있던 컬럼이 시스템이 변경됨에 따라 중복을 허용하게 될 수도 있다
  - 복합키가 적합한 경우에 이를 사용하지만, 복합키의 FK 또한 복합키가 되어야 함에 유의해야 한다

## 키가 없는 엔트리

RDBMS에서 참조정합성(Referential Integrity)은 데이터베이스 설계 및 운영에서 중요한 부분이다.
어떤 컬럼(묶음)에 FK 제약조건을 선언하면 그 컬럼에 들어가는 값은 부모테이블의 PK 또는 UNIQUE KEY에 존재해야 한다.

그러나 어떤 개발자는 참조 정합성 제약조건을 무시하라는 말을 한다. 그 이유는 다음과 같다.

- 데이터 업데이트 시 제약조건과 충돌할 수 있다
- 참조 정합성 제약족너을 지원할 수 없는 매우 융통성 있는 데이터베이스 설계를 사용하고 있다
- FK에 데이터베이스가 자동생성하는 인덱스때문에 성능에 영향이 있다고 믿는다
- FK를 지원하지 않는 데이터베이스를 사용하고 있다

### 안티패턴: 제약조건 무시

FK 제약조건을 생략하는 것이 데이터베이스 설계를 단순하고 유연하게 만드는 것처럼 보이지만 다른 대가를 치러야 한다.
참조 정합성을 보장하기 위한 코드를 직접 작성하는 책임을 떠안아야 하기 때문이다.

- 무결점 코드
  - FK 제약조건을 사용하지 않고 참조 정합성을 만족하기 위해, 변경전 별도의 SELECT 쿼리를 실행해 정합성 유지여부를 확인해야 한다.
  - 확인을 위한 쿼리를 실행한 직후 다른 클라이언트의 요청으로 해당 값이 변경되는 경우 정합성이 유지되지 않는다
  - 이를 방지하기 위한 유일한 해결책은 테이블을 잠근뒤 일련의 작업을 진행하는 것이지만, 엄청난 성능저하가 발생할 것이다

- 오류 확인
  - 깨진 참조를 수동으로 확인해야 한다면 얼마나 자주 해야하는지에 대한 의문이 있을 것이다
  - 만약 깨진 참조를 발견한다 하여도 올바르게 수정할 수 있을지 확신할 수도 없다

- 누구의 잘못인가
  - 애플리케이션이 아니라 쿼리 도구나 스크립트를 이용해서 데이터베이스를 직접 수정할 수도 있다
  - 이런 경우 깨진 참조가 발생할 가능성이 더욱크지만, 애플리케이션 수명주기상 이런 일이 발생할 수도 있음을 인정해야 한다

- 진퇴양난 업데이트
  - 많은 개발자들이 여러 테이블에 걸친 관련 컬럼 업데이트가 불편하므로 FK 제약조건 사용을 꺼린다
  - 이 문제는 특히 자식행이 참조하고 있는 컬럼을 UPDATE 하려할 때 발생한다
  - 부모를 업데이트 하기 전에는 자식 행을 업데이트 할 수 없고, 자신을 참조하는 자식 행을 업데이트하기 전에는 부모를 업데이트 할 수 없다

### 안티패턴 인식 방법: 제약조건 무시

다음과 같은 경우 키가 없는 엔트리 안티패턴일 가능성이 있다

- 어떤 값이 한 테이블에는 있고 다른 테이블에 없는지 확인하려는 쿼리 작성방법을 고민
- 테이블에 삽입하면서 다른 테이블에 어떤 값이 있는지 빠르게 확인하는 방법을 고민

### 해법: 제약조건 선언하기

데이터 정합성 오류를 찾아내 정정하는 대신 FK를 사용하여 처음부터 잘못된 데이터가 입력되지 않도록 한다.
이 강제사항을 우회할 코드는 존재할 수 없다.

- 여러 테이블 변경 지원
  - FK는 애플리케이션 코드가 행할 수 없는 cascading update를 수행할 수 있다
  - 이경우 부모행을 업데이트/삭제 하는 경우 해당 행을 참조하는 자식행을 알아서 처리한다
  - FK 제약조건의 `ON UPDATE` 또는 `ON DELETE` 절을 선언하는 방식에 따라 단계적 작업 결과를 제어할 수 있다

- 오버헤드?
  - FK 제약조건에 약간의 오버헤드가 있는 것은 사실이다
  - 그러나 다른조건과 비교했을 때 FK가 훨씬 효율적이다
    - INSERT, UPDATE, DELETE 실행이전 데이터 확인을 위해 SELECT 실행 불필요(경쟁상태 문제도 발생할 수 있음)
    - 여러 테이블을 변경하기 위해 테이블 lock을 사용할 필요가 없다
    - 불필요하게 발생하는 참조가 없는 데이터를 삭제하기 위해 스크립트를 실행할 필요가 없다

## 엔티티-속성-값
