# SQL Anti Patterns

## 무단횡단

다대다 관계를 위한 교차테이블 생성을 피하기 위해 쉼표로 구분된 목록을 사용하는 경우

### 안티패턴: 쉼표로 구분된 목록에 저장

- 해당 데이터에서 일치하는 데이터를 검색하는 경우
- 해당 데이터를 FK로 사용해서 연관 데이터를 조회하는 경우 조인 자체도 어려울 뿐더러 조인시 인덱스를 활용할 기회가 사라진다
- 집계쿼리는 행의 그룹에 대해 사용하도록 되어 있으므로 사용이 어렵다
- 데이터 목록 정렬이 어렵다
- 연관 데이터의 갱신이 어렵다
- 입력 데이터의 유효성 검증이 어렵다
- 구분자 문자로 어떤것을 선택해야 할지에 대한 문제(comma를 사용한다면 본문의 comma는 어떻게 처리할 것인가?)
- 데이터 타입에 따라 목록 저장 길이 제한이 존재한다

### 쉼표로 구분된 목록 저장 사용이 합당한 경우

- 특정 쿼리는 역정규화를 적용해 성능을 높일 수 있다
- 이 경우 목록안의 개별항목에 접근할 필요가 없어야 한다
- 역정규화 적용은 보수적으로 접근해야 한다

### 해법: 교차 테이블 생성

- 어떤 테이블이 FK로 두 테이블을 참조할 때 이를 교차 테이블이라 한다
- 별도의 테이블에 각각의 행으로 저장하고 두 테이블 사이 다대다 관계를 생성한다
- 목록에 항목 추가/삭제는 교차 테이블에 행 삽입 삭제로 할 수 있다

## 순진한 트리

데이터가 재귀적 관계를 가지는 것은 흔한일이다. 데이터는 트리나 계층적 구조가 될 수 있다.
이러한 데이터를 조회할 때는 개별항목을 조회, 관련 부분만 조회, 전체를 조회하는 경우가 존재한다.

무한 계층 댓글, 조직도 등이 해당 자료구조라 할 수 있다.

### 안티패턴: 항상 부모에 의존

- 계층 데이터를 저장할 때 부모 데이터 id를 갖고 있는 방식의 설계를 인접 목록 (adjacency list)라 한다
- 인접목록에서 모든 자식 조회하기를 제대로 수행하지 못한다면 안티패턴이 된다
  - JOIN은 횟수가 정해져 있으므로 모든 계층을 가져온다면 많은 수행이 필요하고, 계층 제한이 없다면 실행조차 어렵다
  - 전체 데이터를 가져와 애플리케이션에서 계층을 생성하는 것은 느리고 매우 비효율적이다
- 인접 목록에서 노드 추가나 이동은 간단한 편이다. 그러나 삭제는 상당히 복잡하다.

### 항상 부모에 의존 사용이 합당한 경우

주어진 노드의 부모나 자식을 바로 얻거나 새로운 노드 추가만 주로 이루어지는 경우 인접목록 사용이 적합할 수도 있다.

어떤 DBMS는 인접 목록 형식으로 젖아된 계층 구조를 지원하기 위한 SQL 확장기능을 지원한다.
SQL-99 표준에는 WITH 키워드에 Common Table Expression을 사용한 재퀴적 쿼리문법이 있다.

### 해법: 대안 트리 모델 사용

계층 데이터 저장시 인접 목록의 대안으로 경로 열거, 중첩집합, 클로저 테이블 등이 있다.

#### 경로 열거(Path Enumeration)

인접목록의 약점중 하나는 트리에서 노드의 조상을 얻는데 비용이 크다는 것이다.
경로 열거 방법에서는 일련의 조상을 각 노드의 속성으로 저장해서 해결한다. (디렉토리 경로가 일종의 경로 열거 형태)

데이터 노드의 경로도 root 부터 시작해 `/`로 구분하여 하나의 속성으로 저장가능하다.

새로운 노드를 삽입할 때 다른 노드를 수정하지 않고 non-leaf 노드를 삽입할 수 있다.
(새노드의 부모 경로에 새로운 노드의 id를 덧붙이기만 하면 된다)

만약 구분자 사이 요소길이가 같은 경우 데이터를 계층구조에 따라 쉽게 정렬할 수 있다. (단순히 문자를 정렬하는 것과 같다)

경로 열거는 무단횡단과 비슷한 단점이 있다.
경로 문자열을 유지하는 것이 애플리케이션 코드에 종속되고, 검증에 비용이 많이 든다. 또한 길이도 제한된다.

#### 중첩집합(Nested Sets)

중첩 집합은 각 노드가 자신의 부모대신 자손의 집합에 대한 정보를 저장한다.

각 노드는 nleft, nright (다른이름도 상관 없음)라는 두 숫자를 가진다.
nleft는 모든 자식 노드의 nleft 수 보다 작고, lright는 모든 자식 노드의 nright 수 보다 크다.

이 경우 현재 노드의 nleft와 nright 사이의 값을, nleft 값으로 가진 노드를 찾으면 모든 자식 노드를 찾는 것이다.
반대로 nleft와 nright 사이의 값으로 현재 노드의 nleft값을 가지는 노드를 찾으면 모든 조상 노드를 찾을 수 있다.

중첩 집합 모델의 강점은, 자식을 가진 노드를 삭제 했을 때 그 자손이 자동으로 삭제 노드의 부모 자손이 된다는 점이다.

그러나 직접적인 자식이나 부모조회는 복잡하다.
어떤 노드가 직계 조상/후손 노드인지 알 수 없으므로 두 노드사이의 조상/후손이 있는 지를 비교하여 없는 경우를 찾아야 한다.

노드 추가/이동도 복잡하다. 이 경우 새 노드의 left보다 큰 모든 노드의 left, right 값을 재계산 해야 한다.

#### 클로저 테이블(Closure Table)
