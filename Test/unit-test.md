# 단위테스트 (Unit Test)

단위테스트는 버그를 찾기위한 방법이 아니다.
하나의 기능에 대해 알고 있고있는 입력값을 제공하면 알고 있고있는 결과값이 출력되는지 확인하는 것이다.

즉, 각각의 단위들이 개별적으로 작동하는지 조사하는 것이다.

## 단위테스트 가이드

### 하나의 테스트 케이스는 단위 기능 중 하나의 시나리오만 테스트

매개변수를 가지는 함수의 반환값을 검증하는 테스트를 작성한다면 다음과 같은 경우가 존재할 수 있다

1. 첫 번째 파라미터가 널 값일 경우 예외 객체를 반환해야 한다
2. 두 번째 파라미터가 널 값일 경우 예외 객체를 반환해야 한다
3. 두 개의 파라미터 모두가 널 값일 경우 예외 객체를 반환해야 한다
4. 파라미터가 정상 범위 안일 경우 작업 실행 후 결과 값을 반환해야 한다

이를 하나의 테스트 케이스에 작성하지 않고, 분리하여 작성한다면 코드 수정 및 리팩토링시 효과적이다

### 불필요한 검증 구문을 작성하지 않는다

단위 내의 모든 것에 대해 검증 구문을 작성하는 대신 테스트하려고 하는 하나의 시나리오에 집중해야 한다.
테스트케이스 실행을 통해서 문제점을 특정하여 검증해야 하기 때문이다.

여러 가지를 검증해야 한다면 테스트 케이스를 나누어야 한다.

### 각 테스트는 독립적이어야 한다

다른 테스트에 의존적인 테스트를 작성하면 안된다.
이러한 테스트들은 테스트의 근본적 실패 원인을 추적과 유지보수가 어렵다.

테스트 조건을 설정하기 위해서 @Before/@After과 같은 JUnit의 애노테이션을 사용하고,
보다 많은 설정이 필요한 경우라면 테스트 클래스를 분리해야 한다.

### 모든 외부 서비스와 상태들에 테스트 더블을 사용해라

파일 입출력, 네트워크, 데이터베이스등을 사용하는 경우
테스트 구문 실행 순서에 따라 테스트 결과가 달라지거나 외부자원의 조건에 따라 결과가 달라진다.

### 시스템 설정 파일에 관한 단위 테스트를 작성하지 않는다

시스템 설정은 단위 테스트의 범위가 아니다. (설정값은 별도의 설정 파일로 분리된다)

### 단위 테스트 케이스의 이름은 명확하고 일관되게 테스트의 의미를 반영해야 한다

테스트 케이스의 이름은 항상 테스트의 의도가 무엇인지 반영해야 한다.
클래스나 메소드의 이름을 변경해야 하는 경우가 생길 때 테스트 케이스들의 이름이 영향을 받지 않도록 해야한다.

### 예상된 예외 사항을 테스트하는 단위 테스트 코드를 작성하라

예상되는 예외상황을 검증할 때는 try/catch 구문대신 Junit이 지원하는 `expected`를 사용하라

### 정적 변수를 테스트 클래스에 사용하지 않아야 한다

테스트들 간의 독립성을 유지하기 위해 정적 변수를 사용하지 않아야 한다.
어쩔 수 없이 사용해야 하는 경우라면 테스트 케이스마다 초기화해서 사용해야 한다.

### private method에 대한 테스트도 작성되어야 한다

소스의 코드의 핵심적인 부분은 그것이 private 가시성이라도 반드시 테스트해야한다.

물론 많은 이견도 있다.
특히 TDD를 하는 경우 private method는 테스트를 통과한 상태에서 리팩토링을 통해 자연스럽게 생성되는 부분이므로,
테스트 커버리지에 포함된다고 볼 수도 있다.

### 임의의 입력값을 넣으면 안된다

임의의 값(예를 들어 랜덤 값)을 사용한 테스트는 단위 테스트가 지향하는 명확한 입출력 검증과는 거리가 멀다

물론, 임의의 값을 사용하는 기능의 테스트를 작성하지 않아야 한다는 의미는 아니다.(난수 생성 조건 제어)

### Flakiness (될 때도 있고 안될때도 있는 edge case)에 유의해야 한다

- 시간에 의존적인 테스트
- 네트워크에 접근하는 테스트
- 랜덤에 의존하는 테스트
- 멀티스레딩을 사용하는 로직에 대한 테스트
- 운영체제에 따른 차이
- 부동소수점 자릿수 처리
- 정수 크기
- 기본 문자셋

### 테스트 케이스를 우선 작성해 본다

디버깅 전 실패하는 테스트케이스를 우선 작성해본다.
기존에 작성한 테스트케이스에 문제가 있는지 확인을 할 필요가 있다.

리팩토링 하기 전 코드를 깨보고 테스트케이스가 정상인지 확인해본다.
제대로 작동하는 테스트케이스가 존재해야 리팩토링이 가능하기 때문이다.

## Mocking
